# 零碳园区数字孪生系统虚拟电厂与电力交易模块开发指南

## 文档信息
- **版本**: v1.0
- **创建时间**: 2025年6月26日
- **关联文档**: 
  - 《虚拟电厂与电力交易模块深化开发需求规格说明书 v1.0》
  - 《虚拟电厂与电力交易模块技术规格说明书 v1.0》
  - 《虚拟电厂与电力交易模块深化开发实施计划 v1.0》
- **目标读者**: 开发团队、技术负责人、项目经理

## 1. 开发环境搭建

### 1.1 开发工具要求

#### 1.1.1 必需工具
```bash
# Node.js环境
node --version  # >= 18.0.0
npm --version   # >= 9.0.0

# 数据库
mysql --version # >= 8.0
redis-server --version # >= 7.0

# 容器化工具
docker --version # >= 20.0
docker-compose --version # >= 2.0

# 版本控制
git --version # >= 2.30
```

#### 1.1.2 推荐IDE配置
```json
// .vscode/settings.json
{
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true
  },
  "eslint.validate": [
    "javascript",
    "typescript",
    "vue"
  ],
  "typescript.preferences.importModuleSpecifier": "relative",
  "files.associations": {
    "*.vue": "vue"
  }
}
```

### 1.2 项目初始化

#### 1.2.1 克隆项目
```bash
# 克隆主项目
git clone https://github.com/zero-carbon-park/digital-twin-system.git
cd digital-twin-system

# 切换到VPP开发分支
git checkout -b feature/vpp-trading-module

# 安装依赖
npm install
```

#### 1.2.2 环境配置
```bash
# 复制环境配置文件
cp .env.example .env.development
cp .env.example .env.production

# 配置开发环境变量
vim .env.development
```

```bash
# .env.development 示例配置
NODE_ENV=development
PORT=3000

# 数据库配置
DB_HOST=localhost
DB_PORT=3306
DB_NAME=zero_carbon_vpp_dev
DB_USER=vpp_dev_user
DB_PASSWORD=dev_password

# Redis配置
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=

# JWT配置
JWT_SECRET=your_jwt_secret_key
JWT_EXPIRES_IN=24h

# 外部API配置
ELECTRICITY_MARKET_API_URL=https://api.electricity-market.com
ELECTRICITY_MARKET_API_KEY=your_api_key

# 日志配置
LOG_LEVEL=debug
LOG_FILE_PATH=./logs/vpp-module.log
```

### 1.3 数据库初始化

#### 1.3.1 创建数据库
```sql
-- 创建开发数据库
CREATE DATABASE zero_carbon_vpp_dev CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- 创建用户并授权
CREATE USER 'vpp_dev_user'@'localhost' IDENTIFIED BY 'dev_password';
GRANT ALL PRIVILEGES ON zero_carbon_vpp_dev.* TO 'vpp_dev_user'@'localhost';
FLUSH PRIVILEGES;
```

#### 1.3.2 运行数据库迁移
```bash
# 运行数据库迁移
npm run db:migrate

# 填充测试数据
npm run db:seed

# 验证数据库连接
npm run db:test-connection
```

## 2. 项目结构规范

### 2.1 目录结构
```
src/
├── modules/
│   └── vpp/                    # VPP模块根目录
│       ├── controllers/        # 控制器层
│       │   ├── ResourceController.js
│       │   ├── VPPController.js
│       │   ├── StrategyController.js
│       │   └── TradingController.js
│       ├── services/           # 服务层
│       │   ├── ResourceService.js
│       │   ├── VPPService.js
│       │   ├── StrategyService.js
│       │   ├── TradingService.js
│       │   └── AnalyticsService.js
│       ├── models/             # 数据模型
│       │   ├── Resource.js
│       │   ├── VPP.js
│       │   ├── Strategy.js
│       │   └── Trading.js
│       ├── routes/             # 路由定义
│       │   ├── resourceRoutes.js
│       │   ├── vppRoutes.js
│       │   ├── strategyRoutes.js
│       │   └── tradingRoutes.js
│       ├── middleware/         # 中间件
│       │   ├── auth.js
│       │   ├── validation.js
│       │   └── rateLimit.js
│       ├── utils/              # 工具函数
│       │   ├── aggregator.js
│       │   ├── calculator.js
│       │   └── formatter.js
│       ├── config/             # 配置文件
│       │   ├── database.js
│       │   ├── redis.js
│       │   └── market.js
│       └── tests/              # 测试文件
│           ├── unit/
│           ├── integration/
│           └── e2e/
├── shared/                     # 共享模块
│   ├── database/
│   ├── logger/
│   ├── cache/
│   └── utils/
└── app.js                      # 应用入口
```

### 2.2 命名规范

#### 2.2.1 文件命名
```bash
# 控制器文件
{Entity}Controller.js          # 如: ResourceController.js

# 服务文件
{Entity}Service.js             # 如: VPPService.js

# 模型文件
{Entity}.js                    # 如: Resource.js

# 路由文件
{entity}Routes.js              # 如: resourceRoutes.js

# 工具文件
{function}.js                  # 如: aggregator.js

# 测试文件
{Entity}.test.js               # 如: Resource.test.js
{Entity}.integration.test.js   # 如: Resource.integration.test.js
```

#### 2.2.2 变量命名
```javascript
// 常量 - 全大写，下划线分隔
const MAX_RESOURCE_COUNT = 100;
const DEFAULT_STRATEGY_TYPE = 'BASIC';

// 变量和函数 - camelCase
const resourceInstance = new Resource();
const calculateAggregatedPower = (resources) => { /* ... */ };

// 类名 - PascalCase
class ResourceManager {
  constructor() {
    this.resources = [];
  }
}

// 私有属性/方法 - 下划线前缀
class VPPService {
  constructor() {
    this._internalCache = new Map();
  }
  
  _validateResource(resource) {
    // 私有方法
  }
}
```

## 3. 开发流程规范

### 3.1 Git工作流

#### 3.1.1 分支策略
```bash
# 主分支
main                    # 生产环境代码
develop                 # 开发环境代码

# 功能分支
feature/vpp-resource-management
feature/vpp-strategy-engine
feature/vpp-trading-execution

# 修复分支
hotfix/trading-bug-fix
bugfix/resource-validation-issue

# 发布分支
release/v1.0.0
```

#### 3.1.2 提交规范
```bash
# 提交消息格式
<type>(<scope>): <subject>

<body>

<footer>

# 示例
feat(vpp): add resource aggregation algorithm

Implement the core aggregation algorithm for VPP resources:
- Add capacity calculation logic
- Implement efficiency weighting
- Add response time optimization

Closes #123
```

#### 3.1.3 提交类型
```bash
feat:     新功能
fix:      修复bug
docs:     文档更新
style:    代码格式调整
refactor: 代码重构
test:     测试相关
chore:    构建过程或辅助工具变动
perf:     性能优化
```

### 3.2 代码审查流程

#### 3.2.1 Pull Request模板
```markdown
## 变更描述
简要描述本次变更的内容和目的

## 变更类型
- [ ] 新功能
- [ ] Bug修复
- [ ] 文档更新
- [ ] 代码重构
- [ ] 性能优化
- [ ] 其他

## 测试情况
- [ ] 单元测试通过
- [ ] 集成测试通过
- [ ] 手动测试完成
- [ ] 性能测试通过

## 检查清单
- [ ] 代码符合规范
- [ ] 添加了必要的测试
- [ ] 更新了相关文档
- [ ] 没有引入安全风险
- [ ] 向后兼容

## 相关Issue
Closes #issue_number

## 截图/演示
如有UI变更，请提供截图或演示视频
```

#### 3.2.2 审查要点
```yaml
# 代码审查检查项
code_review_checklist:
  functionality:
    - 功能是否按需求实现
    - 边界条件是否处理
    - 错误处理是否完善
    
  code_quality:
    - 代码可读性
    - 命名是否清晰
    - 逻辑是否简洁
    - 是否有重复代码
    
  performance:
    - 算法复杂度是否合理
    - 是否有性能瓶颈
    - 内存使用是否优化
    
  security:
    - 输入验证是否充分
    - 权限控制是否正确
    - 敏感信息是否保护
    
  testing:
    - 测试覆盖率是否足够
    - 测试用例是否全面
    - 集成测试是否通过
```

## 4. 编码规范

### 4.1 JavaScript/Node.js规范

#### 4.1.1 基础规范
```javascript
// 使用严格模式
'use strict';

// 使用const/let，避免var
const API_VERSION = 'v1';
let currentUser = null;

// 函数声明
function calculatePower(resources) {
  // 函数体
}

// 箭头函数（简短函数）
const formatPrice = (price) => `¥${price.toFixed(2)}`;

// 对象解构
const { id, name, capacity } = resource;

// 数组解构
const [first, second] = results;

// 模板字符串
const message = `Resource ${name} has capacity ${capacity}kW`;
```

#### 4.1.2 异步编程规范
```javascript
// 使用async/await而非回调
// ❌ 不推荐
function getResource(id, callback) {
  db.query('SELECT * FROM resources WHERE id = ?', [id], callback);
}

// ✅ 推荐
async function getResource(id) {
  try {
    const result = await db.query('SELECT * FROM resources WHERE id = ?', [id]);
    return result[0];
  } catch (error) {
    logger.error('Failed to get resource:', error);
    throw new Error('Resource not found');
  }
}

// 并行处理
async function getMultipleResources(ids) {
  const promises = ids.map(id => getResource(id));
  return await Promise.all(promises);
}
```

#### 4.1.3 错误处理规范
```javascript
// 自定义错误类
class VPPError extends Error {
  constructor(message, code, statusCode = 500) {
    super(message);
    this.name = 'VPPError';
    this.code = code;
    this.statusCode = statusCode;
  }
}

// 错误处理中间件
const errorHandler = (error, req, res, next) => {
  logger.error('Error occurred:', {
    error: error.message,
    stack: error.stack,
    url: req.url,
    method: req.method,
    ip: req.ip
  });
  
  if (error instanceof VPPError) {
    return res.status(error.statusCode).json({
      success: false,
      error: {
        code: error.code,
        message: error.message
      }
    });
  }
  
  // 未知错误
  res.status(500).json({
    success: false,
    error: {
      code: 'INTERNAL_ERROR',
      message: 'Internal server error'
    }
  });
};
```

### 4.2 数据库操作规范

#### 4.2.1 查询规范
```javascript
// 使用参数化查询防止SQL注入
// ❌ 不安全
const query = `SELECT * FROM resources WHERE name = '${name}'`;

// ✅ 安全
const query = 'SELECT * FROM resources WHERE name = ?';
const result = await db.query(query, [name]);

// 复杂查询使用查询构建器
const resources = await db('resources')
  .select('id', 'name', 'capacity', 'status')
  .where('status', 'ONLINE')
  .andWhere('capacity', '>', 100)
  .orderBy('capacity', 'desc')
  .limit(10);
```

#### 4.2.2 事务处理
```javascript
// 事务处理规范
async function createVPPWithResources(vppData, resourceIds) {
  const trx = await db.transaction();
  
  try {
    // 创建VPP
    const [vppId] = await trx('vpps').insert(vppData);
    
    // 关联资源
    const mappings = resourceIds.map(resourceId => ({
      vpp_id: vppId,
      resource_id: resourceId,
      allocation_ratio: 1.0,
      created_at: new Date()
    }));
    
    await trx('vpp_resource_mappings').insert(mappings);
    
    // 提交事务
    await trx.commit();
    
    return vppId;
  } catch (error) {
    // 回滚事务
    await trx.rollback();
    throw error;
  }
}
```

### 4.3 API设计规范

#### 4.3.1 RESTful API规范
```javascript
// 资源路由设计
// GET /api/v1/vpps                    - 获取VPP列表
// GET /api/v1/vpps/:id                - 获取特定VPP
// POST /api/v1/vpps                   - 创建VPP
// PUT /api/v1/vpps/:id                - 更新VPP
// DELETE /api/v1/vpps/:id             - 删除VPP
// GET /api/v1/vpps/:id/resources      - 获取VPP的资源
// POST /api/v1/vpps/:id/resources     - 为VPP添加资源

// 控制器实现
class VPPController {
  async list(req, res) {
    try {
      const { page = 1, limit = 20, status } = req.query;
      
      const vpps = await VPPService.list({
        page: parseInt(page),
        limit: parseInt(limit),
        status
      });
      
      res.json({
        success: true,
        data: vpps,
        pagination: {
          page,
          limit,
          total: vpps.total
        }
      });
    } catch (error) {
      next(error);
    }
  }
  
  async create(req, res, next) {
    try {
      const vppData = req.body;
      
      // 验证输入
      const validationResult = await validateVPPData(vppData);
      if (!validationResult.isValid) {
        return res.status(400).json({
          success: false,
          error: {
            code: 'VALIDATION_ERROR',
            message: 'Invalid input data',
            details: validationResult.errors
          }
        });
      }
      
      const vpp = await VPPService.create(vppData);
      
      res.status(201).json({
        success: true,
        data: vpp
      });
    } catch (error) {
      next(error);
    }
  }
}
```

#### 4.3.2 输入验证规范
```javascript
// 使用Joi进行输入验证
const Joi = require('joi');

// VPP创建验证规则
const createVPPSchema = Joi.object({
  name: Joi.string().min(1).max(100).required(),
  description: Joi.string().max(500),
  capacity: Joi.number().positive().required(),
  location: Joi.object({
    latitude: Joi.number().min(-90).max(90).required(),
    longitude: Joi.number().min(-180).max(180).required()
  }).required(),
  resource_ids: Joi.array().items(Joi.string().uuid()).min(1).required()
});

// 验证中间件
const validateVPP = (req, res, next) => {
  const { error, value } = createVPPSchema.validate(req.body);
  
  if (error) {
    return res.status(400).json({
      success: false,
      error: {
        code: 'VALIDATION_ERROR',
        message: 'Invalid input data',
        details: error.details.map(detail => ({
          field: detail.path.join('.'),
          message: detail.message
        }))
      }
    });
  }
  
  req.validatedData = value;
  next();
};
```

## 5. 测试规范

### 5.1 单元测试

#### 5.1.1 测试框架配置
```javascript
// jest.config.js
module.exports = {
  testEnvironment: 'node',
  collectCoverageFrom: [
    'src/**/*.js',
    '!src/**/*.test.js',
    '!src/tests/**'
  ],
  coverageThreshold: {
    global: {
      branches: 85,
      functions: 90,
      lines: 90,
      statements: 90
    }
  },
  setupFilesAfterEnv: ['<rootDir>/src/tests/setup.js']
};
```

#### 5.1.2 测试示例
```javascript
// src/modules/vpp/services/VPPService.test.js
const VPPService = require('./VPPService');
const { mockDatabase } = require('../../tests/mocks');

describe('VPPService', () => {
  beforeEach(() => {
    mockDatabase.reset();
  });
  
  describe('create', () => {
    it('should create a VPP with valid data', async () => {
      // Arrange
      const vppData = {
        name: 'Test VPP',
        capacity: 1000,
        location: { latitude: 39.9042, longitude: 116.4074 }
      };
      
      // Act
      const result = await VPPService.create(vppData);
      
      // Assert
      expect(result).toHaveProperty('id');
      expect(result.name).toBe(vppData.name);
      expect(result.capacity).toBe(vppData.capacity);
    });
    
    it('should throw error for invalid capacity', async () => {
      // Arrange
      const vppData = {
        name: 'Test VPP',
        capacity: -100,  // 无效容量
        location: { latitude: 39.9042, longitude: 116.4074 }
      };
      
      // Act & Assert
      await expect(VPPService.create(vppData))
        .rejects
        .toThrow('Invalid capacity value');
    });
  });
  
  describe('calculateAggregatedCapacity', () => {
    it('should correctly aggregate resource capacities', () => {
      // Arrange
      const resources = [
        { capacity: 100, allocation_ratio: 1.0 },
        { capacity: 200, allocation_ratio: 0.8 },
        { capacity: 150, allocation_ratio: 0.6 }
      ];
      
      // Act
      const result = VPPService.calculateAggregatedCapacity(resources);
      
      // Assert
      expect(result).toBe(350); // 100*1.0 + 200*0.8 + 150*0.6
    });
  });
});
```

### 5.2 集成测试

#### 5.2.1 API集成测试
```javascript
// src/modules/vpp/tests/integration/vpp.integration.test.js
const request = require('supertest');
const app = require('../../../app');
const { setupTestDatabase, cleanupTestDatabase } = require('../../tests/helpers');

describe('VPP API Integration Tests', () => {
  beforeAll(async () => {
    await setupTestDatabase();
  });
  
  afterAll(async () => {
    await cleanupTestDatabase();
  });
  
  describe('POST /api/v1/vpps', () => {
    it('should create a new VPP', async () => {
      const vppData = {
        name: 'Integration Test VPP',
        description: 'Test VPP for integration testing',
        capacity: 1500,
        location: {
          latitude: 39.9042,
          longitude: 116.4074
        },
        resource_ids: ['resource-1', 'resource-2']
      };
      
      const response = await request(app)
        .post('/api/v1/vpps')
        .send(vppData)
        .expect(201);
      
      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveProperty('id');
      expect(response.body.data.name).toBe(vppData.name);
    });
    
    it('should return 400 for invalid data', async () => {
      const invalidData = {
        name: '', // 空名称
        capacity: -100 // 负容量
      };
      
      const response = await request(app)
        .post('/api/v1/vpps')
        .send(invalidData)
        .expect(400);
      
      expect(response.body.success).toBe(false);
      expect(response.body.error.code).toBe('VALIDATION_ERROR');
    });
  });
});
```

### 5.3 性能测试

#### 5.3.1 负载测试脚本
```javascript
// src/tests/performance/load-test.js
const autocannon = require('autocannon');

async function runLoadTest() {
  const result = await autocannon({
    url: 'http://localhost:3000',
    connections: 100,
    duration: 30,
    requests: [
      {
        method: 'GET',
        path: '/api/v1/vpps'
      },
      {
        method: 'POST',
        path: '/api/v1/vpps',
        headers: {
          'content-type': 'application/json'
        },
        body: JSON.stringify({
          name: 'Load Test VPP',
          capacity: 1000,
          location: { latitude: 39.9042, longitude: 116.4074 },
          resource_ids: ['test-resource-1']
        })
      }
    ]
  });
  
  console.log('Load test results:');
  console.log(`Requests per second: ${result.requests.average}`);
  console.log(`Latency average: ${result.latency.average}ms`);
  console.log(`Latency p99: ${result.latency.p99}ms`);
  
  // 性能断言
  if (result.requests.average < 100) {
    throw new Error('Performance below threshold: RPS < 100');
  }
  
  if (result.latency.p99 > 1000) {
    throw new Error('Performance below threshold: P99 latency > 1000ms');
  }
}

if (require.main === module) {
  runLoadTest().catch(console.error);
}

module.exports = { runLoadTest };
```

## 6. 部署规范

### 6.1 Docker化

#### 6.1.1 Dockerfile
```dockerfile
# 多阶段构建
FROM node:18-alpine AS builder

WORKDIR /app

# 复制依赖文件
COPY package*.json ./

# 安装依赖
RUN npm ci --only=production

# 生产镜像
FROM node:18-alpine AS production

# 创建非root用户
RUN addgroup -g 1001 -S nodejs
RUN adduser -S vpp -u 1001

WORKDIR /app

# 复制依赖
COPY --from=builder /app/node_modules ./node_modules

# 复制源代码
COPY --chown=vpp:nodejs src/ ./src/
COPY --chown=vpp:nodejs package*.json ./

# 设置环境变量
ENV NODE_ENV=production
ENV PORT=8080

# 暴露端口
EXPOSE 8080

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8080/health || exit 1

# 切换到非root用户
USER vpp

# 启动应用
CMD ["node", "src/app.js"]
```

#### 6.1.2 docker-compose.yml
```yaml
version: '3.8'

services:
  vpp-api:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3000:8080"
    environment:
      - NODE_ENV=production
      - DB_HOST=mysql
      - REDIS_HOST=redis
    depends_on:
      - mysql
      - redis
    networks:
      - vpp-network
    restart: unless-stopped
    
  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_DATABASE: zero_carbon_vpp
      MYSQL_USER: vpp_user
      MYSQL_PASSWORD: vpp_password
    volumes:
      - mysql_data:/var/lib/mysql
      - ./scripts/init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - vpp-network
    restart: unless-stopped
    
  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data
    networks:
      - vpp-network
    restart: unless-stopped
    
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
    depends_on:
      - vpp-api
    networks:
      - vpp-network
    restart: unless-stopped

volumes:
  mysql_data:
  redis_data:

networks:
  vpp-network:
    driver: bridge
```

### 6.2 CI/CD流水线

#### 6.2.1 GitHub Actions配置
```yaml
# .github/workflows/vpp-module.yml
name: VPP Module CI/CD

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'src/modules/vpp/**'
      - 'package*.json'
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'src/modules/vpp/**'

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: testpassword
          MYSQL_DATABASE: test_db
        options: >-
          --health-cmd="mysqladmin ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3
      
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd="redis-cli ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run linting
      run: npm run lint
    
    - name: Run unit tests
      run: npm run test:unit
      env:
        NODE_ENV: test
        DB_HOST: localhost
        DB_PORT: 3306
        REDIS_HOST: localhost
        REDIS_PORT: 6379
    
    - name: Run integration tests
      run: npm run test:integration
      env:
        NODE_ENV: test
        DB_HOST: localhost
        DB_PORT: 3306
        REDIS_HOST: localhost
        REDIS_PORT: 6379
    
    - name: Generate coverage report
      run: npm run test:coverage
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info
    
    - name: Run security audit
      run: npm audit --audit-level moderate
  
  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
    
    - name: Login to Container Registry
      uses: docker/login-action@v2
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        tags: |
          ghcr.io/${{ github.repository }}/vpp-module:latest
          ghcr.io/${{ github.repository }}/vpp-module:${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
  
  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
    - name: Deploy to production
      run: |
        echo "Deploying VPP module to production"
        # 这里添加实际的部署脚本
```

## 7. 监控和日志

### 7.1 日志规范

#### 7.1.1 日志配置
```javascript
// src/shared/logger/index.js
const winston = require('winston');
const path = require('path');

// 日志格式
const logFormat = winston.format.combine(
  winston.format.timestamp({
    format: 'YYYY-MM-DD HH:mm:ss'
  }),
  winston.format.errors({ stack: true }),
  winston.format.json()
);

// 创建logger实例
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: logFormat,
  defaultMeta: {
    service: 'vpp-module',
    version: process.env.npm_package_version
  },
  transports: [
    // 错误日志文件
    new winston.transports.File({
      filename: path.join(process.env.LOG_DIR || './logs', 'error.log'),
      level: 'error',
      maxsize: 10 * 1024 * 1024, // 10MB
      maxFiles: 5
    }),
    
    // 所有日志文件
    new winston.transports.File({
      filename: path.join(process.env.LOG_DIR || './logs', 'combined.log'),
      maxsize: 10 * 1024 * 1024, // 10MB
      maxFiles: 10
    })
  ]
});

// 开发环境添加控制台输出
if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.combine(
      winston.format.colorize(),
      winston.format.simple()
    )
  }));
}

module.exports = logger;
```

#### 7.1.2 日志使用规范
```javascript
// 在服务中使用日志
const logger = require('../../shared/logger');

class VPPService {
  async create(vppData) {
    logger.info('Creating new VPP', {
      operation: 'vpp_create',
      data: { name: vppData.name, capacity: vppData.capacity }
    });
    
    try {
      const vpp = await this.repository.create(vppData);
      
      logger.info('VPP created successfully', {
        operation: 'vpp_create_success',
        vpp_id: vpp.id,
        duration: Date.now() - startTime
      });
      
      return vpp;
    } catch (error) {
      logger.error('Failed to create VPP', {
        operation: 'vpp_create_error',
        error: error.message,
        stack: error.stack,
        data: vppData
      });
      
      throw error;
    }
  }
}
```

### 7.2 性能监控

#### 7.2.1 Prometheus指标
```javascript
// src/shared/metrics/index.js
const promClient = require('prom-client');

// 创建指标注册表
const register = new promClient.Registry();

// 默认指标
promClient.collectDefaultMetrics({ register });

// 自定义指标
const httpRequestDuration = new promClient.Histogram({
  name: 'http_request_duration_seconds',
  help: 'Duration of HTTP requests in seconds',
  labelNames: ['method', 'route', 'status_code'],
  buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]
});

const httpRequestTotal = new promClient.Counter({
  name: 'http_requests_total',
  help: 'Total number of HTTP requests',
  labelNames: ['method', 'route', 'status_code']
});

const vppOperationsTotal = new promClient.Counter({
  name: 'vpp_operations_total',
  help: 'Total number of VPP operations',
  labelNames: ['operation', 'status']
});

const tradingExecutionDuration = new promClient.Histogram({
  name: 'trading_execution_duration_seconds',
  help: 'Duration of trading execution in seconds',
  labelNames: ['strategy_type', 'market_type'],
  buckets: [0.1, 0.5, 1, 2, 5, 10, 30]
});

// 注册指标
register.registerMetric(httpRequestDuration);
register.registerMetric(httpRequestTotal);
register.registerMetric(vppOperationsTotal);
register.registerMetric(tradingExecutionDuration);

module.exports = {
  register,
  httpRequestDuration,
  httpRequestTotal,
  vppOperationsTotal,
  tradingExecutionDuration
};
```

#### 7.2.2 监控中间件
```javascript
// src/shared/middleware/metrics.js
const { httpRequestDuration, httpRequestTotal } = require('../metrics');

const metricsMiddleware = (req, res, next) => {
  const startTime = Date.now();
  
  res.on('finish', () => {
    const duration = (Date.now() - startTime) / 1000;
    const route = req.route ? req.route.path : req.path;
    
    httpRequestDuration
      .labels(req.method, route, res.statusCode)
      .observe(duration);
    
    httpRequestTotal
      .labels(req.method, route, res.statusCode)
      .inc();
  });
  
  next();
};

module.exports = metricsMiddleware;
```

## 8. 安全规范

### 8.1 认证授权

#### 8.1.1 JWT认证实现
```javascript
// src/shared/auth/jwt.js
const jwt = require('jsonwebtoken');
const { promisify } = require('util');
const logger = require('../logger');

class JWTAuth {
  constructor() {
    this.secret = process.env.JWT_SECRET;
    this.expiresIn = process.env.JWT_EXPIRES_IN || '24h';
  }
  
  generateToken(payload) {
    return jwt.sign(payload, this.secret, {
      expiresIn: this.expiresIn,
      issuer: 'zero-carbon-vpp',
      audience: 'vpp-users'
    });
  }
  
  async verifyToken(token) {
    try {
      const decoded = await promisify(jwt.verify)(token, this.secret);
      return { success: true, payload: decoded };
    } catch (error) {
      logger.warn('JWT verification failed', {
        error: error.message,
        token: token.substring(0, 20) + '...'
      });
      return { success: false, error: error.message };
    }
  }
}

// 认证中间件
const authMiddleware = async (req, res, next) => {
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        success: false,
        error: {
          code: 'MISSING_TOKEN',
          message: 'Authentication token required'
        }
      });
    }
    
    const token = authHeader.substring(7);
    const jwtAuth = new JWTAuth();
    const result = await jwtAuth.verifyToken(token);
    
    if (!result.success) {
      return res.status(401).json({
        success: false,
        error: {
          code: 'INVALID_TOKEN',
          message: 'Invalid authentication token'
        }
      });
    }
    
    req.user = result.payload;
    next();
  } catch (error) {
    logger.error('Authentication error', { error: error.message });
    res.status(500).json({
      success: false,
      error: {
        code: 'AUTH_ERROR',
        message: 'Authentication failed'
      }
    });
  }
};

module.exports = { JWTAuth, authMiddleware };
```

#### 8.1.2 权限控制
```javascript
// src/shared/auth/permissions.js
const logger = require('../logger');

// 权限定义
const PERMISSIONS = {
  VPP_READ: 'vpp:read',
  VPP_WRITE: 'vpp:write',
  VPP_DELETE: 'vpp:delete',
  RESOURCE_READ: 'resource:read',
  RESOURCE_WRITE: 'resource:write',
  STRATEGY_READ: 'strategy:read',
  STRATEGY_WRITE: 'strategy:write',
  STRATEGY_EXECUTE: 'strategy:execute',
  TRADING_READ: 'trading:read',
  TRADING_EXECUTE: 'trading:execute'
};

// 角色权限映射
const ROLE_PERMISSIONS = {
  admin: Object.values(PERMISSIONS),
  operator: [
    PERMISSIONS.VPP_READ,
    PERMISSIONS.VPP_WRITE,
    PERMISSIONS.RESOURCE_READ,
    PERMISSIONS.RESOURCE_WRITE,
    PERMISSIONS.STRATEGY_READ,
    PERMISSIONS.STRATEGY_WRITE,
    PERMISSIONS.STRATEGY_EXECUTE,
    PERMISSIONS.TRADING_READ,
    PERMISSIONS.TRADING_EXECUTE
  ],
  viewer: [
    PERMISSIONS.VPP_READ,
    PERMISSIONS.RESOURCE_READ,
    PERMISSIONS.STRATEGY_READ,
    PERMISSIONS.TRADING_READ
  ]
};

// 权限检查中间件
const requirePermission = (permission) => {
  return (req, res, next) => {
    const user = req.user;
    
    if (!user) {
      return res.status(401).json({
        success: false,
        error: {
          code: 'UNAUTHORIZED',
          message: 'Authentication required'
        }
      });
    }
    
    const userPermissions = ROLE_PERMISSIONS[user.role] || [];
    
    if (!userPermissions.includes(permission)) {
      logger.warn('Permission denied', {
        user_id: user.id,
        role: user.role,
        required_permission: permission,
        user_permissions: userPermissions
      });
      
      return res.status(403).json({
        success: false,
        error: {
          code: 'FORBIDDEN',
          message: 'Insufficient permissions'
        }
      });
    }
    
    next();
  };
};

module.exports = {
  PERMISSIONS,
  ROLE_PERMISSIONS,
  requirePermission
};
```

### 8.2 输入安全

#### 8.2.1 SQL注入防护
```javascript
// 使用参数化查询
const mysql = require('mysql2/promise');

class DatabaseService {
  constructor() {
    this.pool = mysql.createPool({
      host: process.env.DB_HOST,
      user: process.env.DB_USER,
      password: process.env.DB_PASSWORD,
      database: process.env.DB_NAME,
      waitForConnections: true,
      connectionLimit: 10,
      queueLimit: 0
    });
  }
  
  async query(sql, params = []) {
    try {
      const [rows] = await this.pool.execute(sql, params);
      return rows;
    } catch (error) {
      logger.error('Database query error', {
        sql: sql.substring(0, 100),
        error: error.message
      });
      throw error;
    }
  }
  
  // 安全的查询方法
  async findVPPsByUser(userId, filters = {}) {
    let sql = 'SELECT * FROM vpps WHERE user_id = ?';
    const params = [userId];
    
    if (filters.status) {
      sql += ' AND status = ?';
      params.push(filters.status);
    }
    
    if (filters.capacity_min) {
      sql += ' AND capacity >= ?';
      params.push(filters.capacity_min);
    }
    
    return await this.query(sql, params);
  }
}
```

#### 8.2.2 XSS防护
```javascript
// src/shared/security/xss.js
const xss = require('xss');

// XSS过滤配置
const xssOptions = {
  whiteList: {
    // 允许的HTML标签（如果需要）
  },
  stripIgnoreTag: true,
  stripIgnoreTagBody: ['script']
};

// XSS防护中间件
const xssProtection = (req, res, next) => {
  // 清理请求体
  if (req.body) {
    req.body = sanitizeObject(req.body);
  }
  
  // 清理查询参数
  if (req.query) {
    req.query = sanitizeObject(req.query);
  }
  
  next();
};

// 递归清理对象
function sanitizeObject(obj) {
  if (typeof obj === 'string') {
    return xss(obj, xssOptions);
  }
  
  if (Array.isArray(obj)) {
    return obj.map(sanitizeObject);
  }
  
  if (obj && typeof obj === 'object') {
    const sanitized = {};
    for (const [key, value] of Object.entries(obj)) {
      sanitized[key] = sanitizeObject(value);
    }
    return sanitized;
  }
  
  return obj;
}

module.exports = { xssProtection, sanitizeObject };
```

## 9. 总结

本开发指南为虚拟电厂与电力交易模块的开发提供了全面的技术指导，涵盖了:

### 9.1 核心内容
- **环境搭建**: 开发工具、项目初始化、数据库配置
- **项目规范**: 目录结构、命名规范、代码组织
- **开发流程**: Git工作流、代码审查、持续集成
- **编码规范**: JavaScript规范、API设计、错误处理
- **测试规范**: 单元测试、集成测试、性能测试
- **部署规范**: Docker化、CI/CD流水线
- **监控日志**: 日志规范、性能监控、告警配置
- **安全规范**: 认证授权、输入验证、安全防护

### 9.2 关键原则
1. **代码质量**: 严格的编码规范和代码审查
2. **测试驱动**: 高覆盖率的自动化测试
3. **安全第一**: 全方位的安全防护措施
4. **性能优化**: 持续的性能监控和优化
5. **可维护性**: 清晰的架构和完善的文档

### 9.3 实施建议
1. **团队培训**: 确保所有开发人员熟悉本指南
2. **工具配置**: 统一开发环境和工具配置
3. **持续改进**: 根据项目进展不断完善规范
4. **质量把控**: 严格执行代码审查和测试要求
5. **文档维护**: 及时更新文档和规范

通过遵循本开发指南，确保虚拟电厂与电力交易模块的高质量交付和长期可维护性。

---

**文档状态**: 已完成  
**适用版本**: v1.0+  
**更新频率**: 根据项目需求及时更新  
**维护责任**: 技术负责人和开发团队