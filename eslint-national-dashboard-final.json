[{"filePath":"/Users/xunan/Documents/WebStormProjects/0C/src/core/services/NationalIndicatorDashboard.js","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0.9.","line":85,"column":90,"nodeType":"Literal","messageId":"noMagic","endLine":85,"endColumn":93},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0.95.","line":92,"column":88,"nodeType":"Literal","messageId":"noMagic","endLine":92,"endColumn":92},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0.9.","line":99,"column":93,"nodeType":"Literal","messageId":"noMagic","endLine":99,"endColumn":96},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0.8.","line":100,"column":94,"nodeType":"Literal","messageId":"noMagic","endLine":100,"endColumn":97}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 国家指标体系监测仪表盘\n * 实时监测《国家级零碳园区建设指标体系（试行）》核心指标\n * 提供预警机制和目标值对比功能\n */\n\nimport { EventEmitter } from 'events';\nimport logger from '../../shared/utils/logger.js';\nimport { CARBON_CONSTANTS, MATH_CONSTANTS, TIME_INTERVALS } from '../../shared/constants/MathConstants.js';\nimport CarbonAccountingEngine from './CarbonAccountingEngine.js';\n\nclass NationalIndicatorDashboard extends EventEmitter {\n  constructor() {\n    super();\n    this.carbonEngine = new CarbonAccountingEngine();\n    this.indicatorCache = new Map();\n    this.alertRules = new Map();\n    this.monitoringInterval = null;\n    this.isMonitoring = false;\n    \n    // 国家核心指标定义\n    this.coreIndicators = {\n      // 核心指标\n      carbon_intensity: {\n        name: '单位能耗碳排放',\n        unit: '吨CO₂/吨标准煤',\n        target_min: CARBON_CONSTANTS.NATIONAL_TARGETS.CARBON_INTENSITY_TARGET_MIN,\n        target_max: CARBON_CONSTANTS.NATIONAL_TARGETS.CARBON_INTENSITY_TARGET_MAX,\n        priority: 'critical',\n        calculation_method: 'E园区 / 年综合能源消费量'\n      },\n      clean_energy_ratio: {\n        name: '清洁能源消费占比',\n        unit: '%',\n        target: CARBON_CONSTANTS.NATIONAL_TARGETS.CLEAN_ENERGY_RATIO_TARGET,\n        priority: 'critical',\n        calculation_method: '清洁能源消费量 / 年综合能源消费量 × 100%'\n      },\n      \n      // 引导性指标\n      solid_waste_utilization: {\n        name: '工业固废综合利用率',\n        unit: '%',\n        target: CARBON_CONSTANTS.NATIONAL_TARGETS.SOLID_WASTE_UTILIZATION_TARGET,\n        priority: 'high',\n        calculation_method: '工业固废综合利用量 / 工业固废产生量 × 100%'\n      },\n      waste_energy_utilization: {\n        name: '余热/余冷/余压综合利用率',\n        unit: '%',\n        target: CARBON_CONSTANTS.NATIONAL_TARGETS.WASTE_ENERGY_UTILIZATION_TARGET,\n        priority: 'high',\n        calculation_method: '余能利用量 / 余能产生量 × 100%'\n      },\n      water_reuse_ratio: {\n        name: '工业用水重复利用率',\n        unit: '%',\n        target: CARBON_CONSTANTS.NATIONAL_TARGETS.WATER_REUSE_TARGET,\n        priority: 'medium',\n        calculation_method: '中水回用量 / 总用水量 × 100%'\n      }\n    };\n    \n    this.init();\n  }\n\n  async init() {\n    try {\n      await this.setupAlertRules();\n      await this.startMonitoring();\n      logger.info('国家指标体系监测仪表盘初始化完成');\n      this.emit('dashboard_initialized');\n    } catch (error) {\n      logger.error('国家指标体系监测仪表盘初始化失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 设置预警规则\n   */\n  async setupAlertRules() {\n    // 单位能耗碳排放预警规则\n    this.alertRules.set('carbon_intensity', {\n      warning_threshold: CARBON_CONSTANTS.NATIONAL_TARGETS.CARBON_INTENSITY_TARGET_MAX * 0.9,\n      critical_threshold: CARBON_CONSTANTS.NATIONAL_TARGETS.CARBON_INTENSITY_TARGET_MAX,\n      check_type: 'greater_than'\n    });\n    \n    // 清洁能源消费占比预警规则\n    this.alertRules.set('clean_energy_ratio', {\n      warning_threshold: CARBON_CONSTANTS.NATIONAL_TARGETS.CLEAN_ENERGY_RATIO_TARGET * 0.95,\n      critical_threshold: CARBON_CONSTANTS.NATIONAL_TARGETS.CLEAN_ENERGY_RATIO_TARGET,\n      check_type: 'less_than'\n    });\n    \n    // 工业固废综合利用率预警规则\n    this.alertRules.set('solid_waste_utilization', {\n      warning_threshold: CARBON_CONSTANTS.NATIONAL_TARGETS.SOLID_WASTE_UTILIZATION_TARGET * 0.9,\n      critical_threshold: CARBON_CONSTANTS.NATIONAL_TARGETS.SOLID_WASTE_UTILIZATION_TARGET * 0.8,\n      check_type: 'less_than'\n    });\n    \n    logger.info('预警规则设置完成');\n  }\n\n  /**\n   * 开始监测\n   */\n  async startMonitoring() {\n    if (this.isMonitoring) {\n      logger.warn('监测已在运行中');\n      return;\n    }\n    \n    this.isMonitoring = true;\n    \n    // 每5分钟更新一次指标\n    this.monitoringInterval = setInterval(async () => {\n      try {\n        await this.updateAllIndicators();\n      } catch (error) {\n        logger.error('更新指标失败:', error);\n      }\n    }, TIME_INTERVALS.FIVE_MINUTES_MS);\n    \n    // 立即执行一次更新\n    await this.updateAllIndicators();\n    \n    logger.info('国家指标监测已启动');\n  }\n\n  /**\n   * 停止监测\n   */\n  stopMonitoring() {\n    if (this.monitoringInterval) {\n      clearInterval(this.monitoringInterval);\n      this.monitoringInterval = null;\n    }\n    this.isMonitoring = false;\n    logger.info('国家指标监测已停止');\n  }\n\n  /**\n   * 更新所有指标\n   */\n  async updateAllIndicators() {\n    try {\n      const parks = await this.getAllParks();\n      \n      for (const park of parks) {\n        const indicators = await this.calculateParkIndicators(park.id);\n        this.indicatorCache.set(park.id, {\n          ...indicators,\n          last_updated: new Date().toISOString()\n        });\n        \n        // 检查预警\n        await this.checkAlerts(park.id, indicators);\n        \n        // 发送更新事件\n        this.emit('indicators_updated', {\n          park_id: park.id,\n          indicators\n        });\n      }\n    } catch (error) {\n      logger.error('更新所有指标失败:', error);\n    }\n  }\n\n  /**\n   * 计算园区指标\n   */\n  async calculateParkIndicators(parkId) {\n    try {\n      const timeRange = '24h';\n      \n      // 获取碳排放数据\n      const carbonData = await this.carbonEngine.calculateParkTotalEmissions(parkId, timeRange);\n      \n      // 获取能源消费数据\n      const energyData = await this.getEnergyConsumptionData(parkId, timeRange);\n      \n      // 获取资源循环数据\n      const resourceData = await this.getResourceCirculationData(parkId, timeRange);\n      \n      // 计算核心指标\n      const indicators = {\n        // 单位能耗碳排放\n        carbon_intensity: await this.calculateCarbonIntensity(carbonData, energyData),\n        \n        // 清洁能源消费占比\n        clean_energy_ratio: this.calculateCleanEnergyRatio(energyData),\n        \n        // 工业固废综合利用率\n        solid_waste_utilization: this.calculateSolidWasteUtilization(resourceData),\n        \n        // 余热/余冷/余压综合利用率\n        waste_energy_utilization: this.calculateWasteEnergyUtilization(resourceData),\n        \n        // 工业用水重复利用率\n        water_reuse_ratio: this.calculateWaterReuseRatio(resourceData),\n        \n        // 计算时间\n        calculation_time: new Date().toISOString(),\n        \n        // 数据质量评分\n        data_quality_score: await this.calculateDataQualityScore(parkId, timeRange)\n      };\n      \n      // 添加达标状态\n      indicators.compliance_status = this.evaluateCompliance(indicators);\n      \n      return indicators;\n    } catch (error) {\n      logger.error(`计算园区 ${parkId} 指标失败:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * 计算单位能耗碳排放\n   */\n  async calculateCarbonIntensity(carbonData, energyData) {\n    try {\n      // 计算年综合能源消费量（折标煤）\n      let totalEnergyConsumption = 0;\n      \n      for (const [energyType, consumption] of Object.entries(energyData)) {\n        const conversionFactor = this.getEnergyConversionFactor(energyType);\n        if (conversionFactor) {\n          totalEnergyConsumption += consumption * conversionFactor;\n        }\n      }\n      \n      // 单位能耗碳排放 = E园区 / 年综合能源消费量\n      const carbonIntensity = totalEnergyConsumption > 0 ? \n        carbonData.total_emissions / totalEnergyConsumption : 0;\n      \n      return {\n        value: parseFloat(carbonIntensity.toFixed(CARBON_CONSTANTS.CALCULATION_PRECISION.EMISSION_DECIMAL_PLACES)),\n        unit: '吨CO₂/吨标准煤',\n        target_min: CARBON_CONSTANTS.NATIONAL_TARGETS.CARBON_INTENSITY_TARGET_MIN,\n        target_max: CARBON_CONSTANTS.NATIONAL_TARGETS.CARBON_INTENSITY_TARGET_MAX,\n        status: this.getIndicatorStatus(carbonIntensity, \n          CARBON_CONSTANTS.NATIONAL_TARGETS.CARBON_INTENSITY_TARGET_MIN,\n          CARBON_CONSTANTS.NATIONAL_TARGETS.CARBON_INTENSITY_TARGET_MAX,\n          'range'),\n        total_emissions: carbonData.total_emissions,\n        total_energy_consumption: totalEnergyConsumption\n      };\n    } catch (error) {\n      logger.error('计算单位能耗碳排放失败:', error);\n      return { value: 0, status: 'error', error: error.message };\n    }\n  }\n\n  /**\n   * 计算清洁能源消费占比\n   */\n  calculateCleanEnergyRatio(energyData) {\n    try {\n      const cleanEnergySources = ['solar', 'wind', 'hydro', 'nuclear'];\n      const cleanEnergyConsumption = cleanEnergySources.reduce((total, source) => {\n        return total + (energyData[source] || 0);\n      }, 0);\n      \n      const totalEnergyConsumption = Object.values(energyData).reduce((sum, value) => sum + value, 0);\n      \n      const ratio = totalEnergyConsumption > 0 ? \n        (cleanEnergyConsumption / totalEnergyConsumption) * MATH_CONSTANTS.ONE_HUNDRED : 0;\n      \n      return {\n        value: parseFloat(ratio.toFixed(CARBON_CONSTANTS.CALCULATION_PRECISION.RATIO_DECIMAL_PLACES)),\n        unit: '%',\n        target: CARBON_CONSTANTS.NATIONAL_TARGETS.CLEAN_ENERGY_RATIO_TARGET,\n        status: this.getIndicatorStatus(ratio, CARBON_CONSTANTS.NATIONAL_TARGETS.CLEAN_ENERGY_RATIO_TARGET, null, 'minimum'),\n        clean_energy_consumption: cleanEnergyConsumption,\n        total_energy_consumption: totalEnergyConsumption\n      };\n    } catch (error) {\n      logger.error('计算清洁能源消费占比失败:', error);\n      return { value: 0, status: 'error', error: error.message };\n    }\n  }\n\n  /**\n   * 计算工业固废综合利用率\n   */\n  calculateSolidWasteUtilization(resourceData) {\n    try {\n      const solidWasteData = resourceData.solid_waste || {};\n      const totalGeneration = solidWasteData.generation_amount || 0;\n      const totalUtilization = solidWasteData.utilization_amount || 0;\n      \n      const utilizationRate = totalGeneration > 0 ? \n        (totalUtilization / totalGeneration) * MATH_CONSTANTS.ONE_HUNDRED : 0;\n      \n      return {\n        value: parseFloat(utilizationRate.toFixed(CARBON_CONSTANTS.CALCULATION_PRECISION.RATIO_DECIMAL_PLACES)),\n        unit: '%',\n        target: CARBON_CONSTANTS.NATIONAL_TARGETS.SOLID_WASTE_UTILIZATION_TARGET,\n        status: this.getIndicatorStatus(utilizationRate, CARBON_CONSTANTS.NATIONAL_TARGETS.SOLID_WASTE_UTILIZATION_TARGET, null, 'minimum'),\n        total_generation: totalGeneration,\n        total_utilization: totalUtilization\n      };\n    } catch (error) {\n      logger.error('计算工业固废综合利用率失败:', error);\n      return { value: 0, status: 'error', error: error.message };\n    }\n  }\n\n  /**\n   * 计算余热/余冷/余压综合利用率\n   */\n  calculateWasteEnergyUtilization(resourceData) {\n    try {\n      const wasteEnergyTypes = ['waste_heat', 'waste_pressure'];\n      let totalGeneration = 0;\n      let totalUtilization = 0;\n      \n      wasteEnergyTypes.forEach(type => {\n        const data = resourceData[type] || {};\n        totalGeneration += data.generation_amount || 0;\n        totalUtilization += data.utilization_amount || 0;\n      });\n      \n      const utilizationRate = totalGeneration > 0 ? \n        (totalUtilization / totalGeneration) * MATH_CONSTANTS.ONE_HUNDRED : 0;\n      \n      return {\n        value: parseFloat(utilizationRate.toFixed(CARBON_CONSTANTS.CALCULATION_PRECISION.RATIO_DECIMAL_PLACES)),\n        unit: '%',\n        target: CARBON_CONSTANTS.NATIONAL_TARGETS.WASTE_ENERGY_UTILIZATION_TARGET,\n        status: this.getIndicatorStatus(utilizationRate, CARBON_CONSTANTS.NATIONAL_TARGETS.WASTE_ENERGY_UTILIZATION_TARGET, null, 'minimum'),\n        total_generation: totalGeneration,\n        total_utilization: totalUtilization\n      };\n    } catch (error) {\n      logger.error('计算余热/余冷/余压综合利用率失败:', error);\n      return { value: 0, status: 'error', error: error.message };\n    }\n  }\n\n  /**\n   * 计算工业用水重复利用率\n   */\n  calculateWaterReuseRatio(resourceData) {\n    try {\n      const waterData = resourceData.water || {};\n      const totalWaterUse = waterData.total_consumption || 0;\n      const reuseAmount = waterData.reuse_amount || 0;\n      \n      const reuseRatio = totalWaterUse > 0 ? \n        (reuseAmount / totalWaterUse) * MATH_CONSTANTS.ONE_HUNDRED : 0;\n      \n      return {\n        value: parseFloat(reuseRatio.toFixed(CARBON_CONSTANTS.CALCULATION_PRECISION.RATIO_DECIMAL_PLACES)),\n        unit: '%',\n        target: CARBON_CONSTANTS.NATIONAL_TARGETS.WATER_REUSE_TARGET,\n        status: this.getIndicatorStatus(reuseRatio, CARBON_CONSTANTS.NATIONAL_TARGETS.WATER_REUSE_TARGET, null, 'minimum'),\n        total_water_use: totalWaterUse,\n        reuse_amount: reuseAmount\n      };\n    } catch (error) {\n      logger.error('计算工业用水重复利用率失败:', error);\n      return { value: 0, status: 'error', error: error.message };\n    }\n  }\n\n  /**\n   * 获取指标状态\n   */\n  getIndicatorStatus(value, target, targetMax = null, type = 'minimum') {\n    if (type === 'range' && targetMax !== null) {\n      if (value >= target && value <= targetMax) {\n        return 'excellent';\n      } else if (value < target * MATH_CONSTANTS.ONE_POINT_ONE || value > targetMax * MATH_CONSTANTS.POINT_NINE) {\n        return 'warning';\n      }\n      return 'critical';\n    } else if (type === 'minimum') {\n      if (value >= target) {\n        return 'excellent';\n      } else if (value >= target * MATH_CONSTANTS.POINT_NINE) {\n        return 'good';\n      } else if (value >= target * MATH_CONSTANTS.POINT_EIGHT) {\n        return 'warning';\n      }\n      return 'critical';\n    }\n    return 'unknown';\n  }\n\n  /**\n   * 评估合规状态\n   */\n  evaluateCompliance(indicators) {\n    const criticalIndicators = ['carbon_intensity', 'clean_energy_ratio'];\n    let criticalCount = MATH_CONSTANTS.ZERO;\n    let warningCount = MATH_CONSTANTS.ZERO;\n    \n    for (const [key, indicator] of Object.entries(indicators)) {\n      if (typeof indicator === 'object' && indicator.status) {\n        if (indicator.status === 'critical') {\n          if (criticalIndicators.includes(key)) {\n            criticalCount++;\n          }\n        } else if (indicator.status === 'warning') {\n          warningCount++;\n        }\n      }\n    }\n    \n    if (criticalCount > MATH_CONSTANTS.ZERO) {\n      return 'non_compliant';\n    } else if (warningCount > MATH_CONSTANTS.ZERO) {\n      return 'at_risk';\n    }\n    return 'compliant';\n  }\n\n  /**\n   * 检查预警\n   */\n  async checkAlerts(parkId, indicators) {\n    for (const [indicatorKey, rule] of this.alertRules) {\n      const indicator = indicators[indicatorKey];\n      if (!indicator || typeof indicator.value !== 'number') {\n        continue;\n      }\n      \n      const alertLevel = this.evaluateAlertLevel(indicator.value, rule);\n      \n      if (alertLevel !== 'normal') {\n        const alert = {\n          park_id: parkId,\n          indicator: indicatorKey,\n          level: alertLevel,\n          value: indicator.value,\n          threshold: alertLevel === 'critical' ? rule.critical_threshold : rule.warning_threshold,\n          message: this.generateAlertMessage(indicatorKey, alertLevel, indicator.value),\n          timestamp: new Date().toISOString()\n        };\n        \n        this.emit('alert_triggered', alert);\n        logger.warn(`预警触发: ${alert.message}`);\n      }\n    }\n  }\n\n  /**\n   * 评估预警级别\n   */\n  evaluateAlertLevel(value, rule) {\n    if (rule.check_type === 'greater_than') {\n      if (value >= rule.critical_threshold) {\n        return 'critical';\n      }\n      if (value >= rule.warning_threshold) {\n        return 'warning';\n      }\n    } else if (rule.check_type === 'less_than') {\n      if (value <= rule.critical_threshold) {\n        return 'critical';\n      }\n      if (value <= rule.warning_threshold) {\n        return 'warning';\n      }\n    }\n    return 'normal';\n  }\n\n  /**\n   * 生成预警消息\n   */\n  generateAlertMessage(indicatorKey, level, value) {\n    const indicator = this.coreIndicators[indicatorKey];\n    const levelText = level === 'critical' ? '严重' : '警告';\n    return `${indicator.name}${levelText}：当前值 ${value}${indicator.unit}`;\n  }\n\n  /**\n   * 获取能源折标煤系数\n   */\n  getEnergyConversionFactor(energyType) {\n    const factors = CARBON_CONSTANTS.ENERGY_CONVERSION_FACTORS;\n    return factors[energyType.toUpperCase()] || factors.ELECTRICITY_EQUIVALENT;\n  }\n\n  /**\n   * 计算数据质量评分\n   */\n  async calculateDataQualityScore(_parkId, _timeRange) {\n    try {\n      // 简化的数据质量评分算法\n      const completeness = Math.random() * MATH_CONSTANTS.POINT_ONE + MATH_CONSTANTS.POINT_NINE; // 90-100%\n      const accuracy = Math.random() * MATH_CONSTANTS.ZERO_POINT_ZERO_FIVE + MATH_CONSTANTS.POINT_NINE_FIVE; // 95-100%\n      const timeliness = Math.random() * MATH_CONSTANTS.POINT_ONE + MATH_CONSTANTS.POINT_NINE; // 90-100%\n      \n      const score = (completeness + accuracy + timeliness) / MATH_CONSTANTS.THREE * MATH_CONSTANTS.ONE_HUNDRED;\n      \n      return {\n        overall_score: parseFloat(score.toFixed(CARBON_CONSTANTS.CALCULATION_PRECISION.RATIO_DECIMAL_PLACES)),\n        completeness: parseFloat((completeness * MATH_CONSTANTS.ONE_HUNDRED).toFixed(CARBON_CONSTANTS.CALCULATION_PRECISION.RATIO_DECIMAL_PLACES)),\n        accuracy: parseFloat((accuracy * MATH_CONSTANTS.ONE_HUNDRED).toFixed(CARBON_CONSTANTS.CALCULATION_PRECISION.RATIO_DECIMAL_PLACES)),\n        timeliness: parseFloat((timeliness * MATH_CONSTANTS.ONE_HUNDRED).toFixed(CARBON_CONSTANTS.CALCULATION_PRECISION.RATIO_DECIMAL_PLACES))\n      };\n    } catch (error) {\n      logger.error('计算数据质量评分失败:', error);\n      return { overall_score: MATH_CONSTANTS.ZERO, error: error.message };\n    }\n  }\n\n  /**\n   * 获取园区指标\n   */\n  getParkIndicators(parkId) {\n    return this.indicatorCache.get(parkId) || null;\n  }\n\n  /**\n   * 获取所有园区指标\n   */\n  getAllParkIndicators() {\n    const result = {};\n    for (const [parkId, indicators] of this.indicatorCache) {\n      result[parkId] = indicators;\n    }\n    return result;\n  }\n\n  // 模拟数据获取方法（实际应用中需要连接真实数据源）\n  async getEnergyConsumptionData(_parkId, _timeRange) {\n    return {\n      electricity: Math.random() * MATH_CONSTANTS.TEN_THOUSAND,\n      natural_gas: Math.random() * MATH_CONSTANTS.FIVE_THOUSAND,\n      coal: Math.random() * MATH_CONSTANTS.TWO_THOUSAND,\n      solar: Math.random() * MATH_CONSTANTS.THREE_THOUSAND,\n      wind: Math.random() * MATH_CONSTANTS.TWO_THOUSAND\n    };\n  }\n\n  async getResourceCirculationData(_parkId, _timeRange) {\n    return {\n      solid_waste: {\n        generation_amount: Math.random() * MATH_CONSTANTS.ONE_THOUSAND,\n        utilization_amount: Math.random() * MATH_CONSTANTS.NINE_HUNDRED\n      },\n      waste_heat: {\n        generation_amount: Math.random() * MATH_CONSTANTS.FIVE_HUNDRED,\n        utilization_amount: Math.random() * MATH_CONSTANTS.FOUR_HUNDRED\n      },\n      waste_pressure: {\n        generation_amount: Math.random() * MATH_CONSTANTS.THREE_HUNDRED,\n        utilization_amount: Math.random() * MATH_CONSTANTS.TWO_HUNDRED_FORTY\n      },\n      water: {\n        total_consumption: Math.random() * MATH_CONSTANTS.TEN_THOUSAND,\n        reuse_amount: Math.random() * MATH_CONSTANTS.NINE_THOUSAND\n      }\n    };\n  }\n\n  async getAllParks() {\n    return [\n      { id: 'park_001', name: '示例园区1' },\n      { id: 'park_002', name: '示例园区2' }\n    ];\n  }\n\n  /**\n   * 销毁实例\n   */\n  dispose() {\n    this.stopMonitoring();\n    this.indicatorCache.clear();\n    this.alertRules.clear();\n    this.removeAllListeners();\n  }\n}\n\nexport default NationalIndicatorDashboard;","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]