[{"filePath":"/Users/xunan/Documents/WebStormProjects/0C/backend/services/energyPredictionService.js","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 4.","line":171,"column":73,"nodeType":"Literal","messageId":"noMagic","endLine":171,"endColumn":74},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 4.","line":171,"column":113,"nodeType":"Literal","messageId":"noMagic","endLine":171,"endColumn":114},{"ruleId":"no-undef","severity":2,"message":"'EnergyData' is not defined.","line":284,"column":38,"nodeType":"Identifier","messageId":"undef","endLine":284,"endColumn":48}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import tf from '@tensorflow/tfjs-node';\n// import { EnergyData } from '../models/index.js'; // 暂时注释掉，使用数据库直接查询\nimport logger from '../../src/shared/utils/logger.js';\nimport { \n  ALGORITHM_CONSTANTS, \n  DATA_PROCESSING_CONSTANTS, \n  TIME_INTERVALS,\n  MATH_CONSTANTS \n} from '../../src/shared/constants/MathConstants.js';\n\nclass EnergyPredictionService {\n  constructor() {\n    this.model = null;\n    this.isModelTrained = false;\n    this.features = ['hour', 'dayOfWeek', 'temperature', 'humidity', 'previousEnergyUsage'];\n    this.target = 'energyUsage';\n    this.initializeModel();\n  }\n\n  /**\n   * 初始化预测模型\n   */\n  async initializeModel() {\n    try {\n      // 创建一个简单的神经网络模型\n      this.model = tf.sequential({\n        layers: [\n          tf.layers.dense({\n            inputShape: [this.features.length],\n            units: ALGORITHM_CONSTANTS.BATCH_SIZE,\n            activation: 'relu',\n            kernelInitializer: 'heNormal',\n          }),\n          tf.layers.dropout({ rate: ALGORITHM_CONSTANTS.VALIDATION_SPLIT }),\n          tf.layers.dense({ units: MATH_CONSTANTS.SIXTEEN, activation: 'relu' }),\n          tf.layers.dense({ units: MATH_CONSTANTS.EIGHT, activation: 'relu' }),\n          tf.layers.dense({ units: MATH_CONSTANTS.ONE }),\n        ],\n      });\n\n      // 编译模型\n      this.model.compile({\n        optimizer: tf.train.adam(ALGORITHM_CONSTANTS.LEARNING_RATE),\n        loss: 'meanSquaredError',\n        metrics: ['mse'],\n      });\n\n      logger.info('能源预测模型初始化成功');\n\n      // 尝试加载已保存的模型\n      await this.loadModel();\n    } catch (error) {\n      logger.error('能源预测模型初始化失败:', error);\n    }\n  }\n\n  /**\n   * 从数据库获取训练数据\n   * @param {number} limit - 获取数据条数\n   * @returns {Promise<{features: number[][], labels: number[]}>} - 特征和标签数据\n   */\n  async fetchTrainingData(limit = DATA_PROCESSING_CONSTANTS.BATCH_SIZE_EXTRA_LARGE) {\n    try {\n      // 暂时返回模拟数据，避免数据库查询错误\n      logger.warn('使用模拟数据进行训练，实际应用中需要连接真实数据库');\n\n      // 生成模拟的能源数据\n      const energyData = [];\n      const now = new Date();\n\n      for (let i = 0; i < Math.min(limit, DATA_PROCESSING_CONSTANTS.BATCH_SIZE_LARGE); i++) {\n        const timestamp = new Date(now.getTime() - i * TIME_INTERVALS.ONE_HOUR_MS); // 每小时一条数据\n        energyData.push({\n          timestamp: timestamp.toISOString(),\n          energyUsage: MATH_CONSTANTS.FIVE_HUNDRED + Math.random() * MATH_CONSTANTS.FIVE_HUNDRED, // 500-1000 kWh\n          temperature: MATH_CONSTANTS.TWENTY + Math.random() * MATH_CONSTANTS.TWENTY, // 20-40°C\n          humidity: MATH_CONSTANTS.FORTY + Math.random() * MATH_CONSTANTS.FORTY, // 40-80%\n        });\n      }\n\n      if (energyData.length < MATH_CONSTANTS.ONE_HUNDRED) {\n        logger.warn('训练数据不足，需要至少100条记录');\n        return null;\n      }\n\n      // 数据预处理\n      const processedData = this.preprocessData(energyData);\n      return processedData;\n    } catch (error) {\n      logger.error('获取训练数据失败:', error);\n      return null;\n    }\n  }\n\n  /**\n   * 数据预处理\n   * @param {Array} data - 原始数据\n   * @returns {Object} - 处理后的特征和标签\n   */\n  preprocessData(data) {\n    // 按时间戳排序\n    const sortedData = [...data].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));\n\n    const features = [];\n    const labels = [];\n\n    // 提取特征和标签\n\n    // TODO: 考虑将此函数拆分为更小的函数 (当前 21 行)\n\n    // TODO: 考虑将此函数拆分为更小的函数 (当前 21 行)\n\n    // TODO: 考虑将此函数拆分为更小的函数 (当前 21 行)\n\n    // TODO: 考虑将此函数拆分为更小的函数 (当前 21 行)\n\n    for (let i = 1; i < sortedData.length; i++) {\n      const current = sortedData[i];\n      const previous = sortedData[i - 1];\n      const date = new Date(current.timestamp);\n\n      // 提取时间特征\n      const hour = date.getHours();\n      const dayOfWeek = date.getDay();\n\n      // 添加特征\n      features.push([\n        hour / MATH_CONSTANTS.TWENTY_THREE, // 归一化到0-1\n        dayOfWeek / MATH_CONSTANTS.SIX, // 归一化到0-1\n        (current.temperature || MATH_CONSTANTS.TWENTY) / MATH_CONSTANTS.FORTY, // 假设温度范围0-40\n        (current.humidity || MATH_CONSTANTS.FIFTY) / MATH_CONSTANTS.ONE_HUNDRED, // 湿度0-100\n        previous.energyUsage / MATH_CONSTANTS.ONE_THOUSAND, // 前一小时能耗，假设最大值1000\n      ]);\n\n      // 添加标签\n      labels.push([current.energyUsage]);\n    }\n\n    return { features, labels };\n  }\n\n  /**\n   * 训练模型\n   * @param {number} epochs - 训练轮次\n   * @param {number} batchSize - 批次大小\n   * @returns {Promise<boolean>} - 训练是否成功\n   */\n  async trainModel(epochs = MATH_CONSTANTS.FIFTY, batchSize = ALGORITHM_CONSTANTS.BATCH_SIZE) {\n    try {\n      logger.info('开始训练能源预测模型...');\n\n      // 获取训练数据\n      const trainingData = await this.fetchTrainingData();\n      if (!trainingData) {\n        return false;\n      }\n\n      // 转换为张量\n      const xs = tf.tensor2d(trainingData.features);\n      const ys = tf.tensor2d(trainingData.labels);\n\n      // 训练模型\n      const history = await this.model.fit(xs, ys, {\n        epochs,\n        batchSize,\n        validationSplit: ALGORITHM_CONSTANTS.VALIDATION_SPLIT,\n        shuffle: true,\n        callbacks: {\n          onEpochEnd: (epoch, logs) => {\n            logger.info(\n              `Epoch ${epoch + 1}/${epochs} - loss: ${logs.loss.toFixed(4)} - val_loss: ${logs.val_loss.toFixed(4)}`\n            );\n          },\n        },\n      });\n\n      // 释放张量内存\n      xs.dispose();\n      ys.dispose();\n\n      const finalLoss = history.history.loss[history.history.loss.length - MATH_CONSTANTS.ONE];\n      const finalValLoss = history.history.val_loss[history.history.val_loss.length - MATH_CONSTANTS.ONE];\n\n      logger.info(\n        `模型训练完成 - 最终损失: ${finalLoss.toFixed(MATH_CONSTANTS.FOUR)} - 最终验证损失: ${finalValLoss.toFixed(MATH_CONSTANTS.FOUR)}`\n      );\n\n      this.isModelTrained = true;\n\n      // 保存模型\n      await this.saveModel();\n\n      return true;\n    } catch (error) {\n      logger.error('模型训练失败:', error);\n      return false;\n    }\n  }\n\n  /**\n   * 保存模型到文件系统\n   * @returns {Promise<void>}\n   */\n  async saveModel() {\n    try {\n      await this.model.save('file://./models/energy-prediction-model');\n      logger.info('模型保存成功');\n    } catch (error) {\n      logger.error('模型保存失败:', error);\n    }\n  }\n\n  /**\n   * 从文件系统加载模型\n   * @returns {Promise<boolean>}\n   */\n  async loadModel() {\n    try {\n      this.model = await tf.loadLayersModel('file://./models/energy-prediction-model/model.json');\n      this.isModelTrained = true;\n      logger.info('模型加载成功');\n      return true;\n    } catch (error) {\n      logger.warn('模型加载失败，将使用新模型:', error.message);\n      return false;\n    }\n  }\n\n  /**\n   * 预测能源消耗\n   * @param {Object} inputData - 输入特征数据\n   * @returns {Promise<number>} - 预测的能源消耗量\n   */\n  async predictEnergyUsage(inputData) {\n    try {\n      if (!this.isModelTrained) {\n        logger.warn('模型尚未训练，正在进行首次训练...');\n        const trainingSuccess = await this.trainModel();\n        if (!trainingSuccess) {\n          logger.error('模型训练失败，无法进行预测');\n          return null;\n        }\n      }\n\n      // 准备输入特征\n      const inputFeatures = [\n        inputData.hour / MATH_CONSTANTS.TWENTY_THREE,\n        inputData.dayOfWeek / MATH_CONSTANTS.SIX,\n        (inputData.temperature || MATH_CONSTANTS.TWENTY) / MATH_CONSTANTS.FORTY,\n        (inputData.humidity || MATH_CONSTANTS.FIFTY) / MATH_CONSTANTS.ONE_HUNDRED,\n        (inputData.previousEnergyUsage || MATH_CONSTANTS.ZERO) / MATH_CONSTANTS.ONE_THOUSAND,\n      ];\n\n      // 转换为张量并进行预测\n      const inputTensor = tf.tensor2d([inputFeatures]);\n      const prediction = this.model.predict(inputTensor);\n      const result = await prediction.data();\n\n      // 释放张量内存\n      inputTensor.dispose();\n      prediction.dispose();\n\n      // 返回预测结果\n      return result[MATH_CONSTANTS.ZERO];\n    } catch (error) {\n      logger.error('能源消耗预测失败:', error);\n      return null;\n    }\n  }\n\n  /**\n   * 批量预测未来24小时能源消耗\n   * @param {Object} baseData - 基础数据（包含温度、湿度等）\n   * @returns {Promise<Array>} - 未来24小时的预测结果\n   */\n  async predict24Hours(baseData) {\n    try {\n      const predictions = [];\n      const now = new Date();\n      const currentHour = now.getHours();\n      const dayOfWeek = now.getDay();\n\n      // 获取最近的能耗数据作为初始值\n      const latestEnergyData = await EnergyData.findOne({\n        order: [['timestamp', 'DESC']],\n      });\n\n      // TODO: 考虑将此函数拆分为更小的函数 (当前 21 行)\n\n      // TODO: 考虑将此函数拆分为更小的函数 (当前 21 行)\n\n      // TODO: 考虑将此函数拆分为更小的函数 (当前 21 行)\n\n      // TODO: 考虑将此函数拆分为更小的函数 (当前 21 行)\n\n      let previousEnergyUsage = latestEnergyData ? latestEnergyData.energyUsage : MATH_CONSTANTS.ZERO;\n\n      // 预测未来24小时\n      for (let i = 0; i < MATH_CONSTANTS.TWENTY_FOUR; i++) {\n        const hour = (currentHour + i) % MATH_CONSTANTS.TWENTY_FOUR;\n\n        // 使用基础数据或默认值\n        const prediction = await this.predictEnergyUsage({\n          hour,\n          dayOfWeek,\n          temperature: baseData.temperature || MATH_CONSTANTS.TWENTY,\n          humidity: baseData.humidity || MATH_CONSTANTS.FIFTY,\n          previousEnergyUsage,\n        });\n\n        // 将当前预测作为下一个预测的前一小时能耗\n        previousEnergyUsage = prediction;\n\n        predictions.push({\n          hour,\n          predictedEnergyUsage: prediction,\n          timestamp: new Date(now.getTime() + i * TIME_INTERVALS.ONE_HOUR_MS),\n        });\n      }\n\n      return predictions;\n    } catch (error) {\n      logger.error('24小时能源预测失败:', error);\n      return [];\n    }\n  }\n}\n\n// 创建单例实例\nconst energyPredictionService = new EnergyPredictionService();\n\n// 当服务启动时训练模型（如果尚未训练）\nif (!energyPredictionService.isModelTrained) {\n  energyPredictionService.trainModel().catch((err) => {\n    logger.error('服务启动时模型训练失败:', err);\n  });\n}\n\nexport default energyPredictionService;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]