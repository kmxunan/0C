[{"filePath":"/Users/xunan/Documents/WebStormProjects/0C/src/core/services/EnergyAnalytics.js","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":681,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":681,"endColumn":44},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":764,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":764,"endColumn":58}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\n// ğŸš¨ å®‰å…¨è­¦å‘Š: æ­¤æ–‡ä»¶åŒ…å«SQLæŸ¥è¯¢ï¼Œè¯·ç¡®ä¿ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢é˜²æ­¢SQLæ³¨å…¥\n// ç¤ºä¾‹: db.query('SELECT * FROM users WHERE id = ?', [userId])\n// é¿å…: db.query('SELECT * FROM users WHERE id = ' + userId)\nimport { dbPromise } from '../../infrastructure/database/index.js';\nimport { v4 as uuidv4 } from 'uuid';\nimport { defaultLogger as logger } from '../../utils/logger.js';\nimport { MATH_CONSTANTS, TIME_INTERVALS, PREVIOUS_TIME_RANGES } from '../../shared/constants/MathConstants.js';\n// å¸¸é‡å®šä¹‰\nconst EFFICIENCY_THRESHOLDS = {\n  EXCELLENT: MATH_CONSTANTS.NINETY,\n  GOOD: MATH_CONSTANTS.EIGHTY,\n  AVERAGE: MATH_CONSTANTS.SEVENTY,\n  POOR: MATH_CONSTANTS.SIXTY,\n  VERY_POOR: MATH_CONSTANTS.FIFTY\n};\n\nconst ANOMALY_THRESHOLDS = {\n  STANDARD_DEVIATIONS: MATH_CONSTANTS.THREE,\n  CHANGE_THRESHOLD: 0.05\n};\n\nconst TIME_CONDITIONS = {\n  ONE_HOUR: '-1 hour',\n  SIX_HOURS: '-6 hours',\n  ONE_DAY: '-1 day',\n  TWO_DAYS: '-2 days',\n  SEVEN_DAYS: '-7 days',\n  THIRTY_DAYS: '-30 days',\n  NINETY_DAYS: '-90 days',\n  ONE_YEAR: '-1 year'\n};\n\n/**\n * èƒ½æºåˆ†ææ¨¡å—\n * æä¾›èƒ½æºæ•°æ®çš„ç»Ÿè®¡åˆ†æã€è¶‹åŠ¿è®¡ç®—å’ŒæŠ¥å‘Šç”ŸæˆåŠŸèƒ½\n */\nclass EnergyAnalytics {\n  constructor() {\n    this.cache = new Map();\n    this.cacheTimeout = TIME_INTERVALS.FIVE_MINUTES_MS; // 5åˆ†é’Ÿç¼“å­˜\n  }\n\n  /**\n   * è·å–è®¾å¤‡èƒ½æºæ¶ˆè€—ç»Ÿè®¡\n   */\n  async getDeviceEnergyStats(deviceId, timeRange = '24h') {\n    try {\n      const cacheKey = `device_stats_${deviceId}_${timeRange}`;\n      const cached = this.getFromCache(cacheKey);\n      if (cached) {return cached;}\n\n      const timeCondition = this.getTimeCondition(timeRange);\n\n      const sql = `\n        SELECT \n          data_type,\n          COUNT(*) as data_points,\n          AVG(value) as avg_value,\n          MIN(value) as min_value,\n          MAX(value) as max_value,\n          SUM(value) as total_value,\n          unit,\n          MIN(timestamp) as start_time,\n          MAX(timestamp) as end_time\n        FROM energy_data \n        WHERE device_id = ? AND timestamp >= datetime('now', ?)\n        GROUP BY data_type, unit\n        ORDER BY data_type\n      `;\n\n      const stats = await this.queryDatabase(sql, [deviceId, timeCondition]);\n\n      // è®¡ç®—é¢å¤–çš„ç»Ÿè®¡æŒ‡æ ‡\n      const enrichedStats = await Promise.all(\n        stats.map(async stat => {\n          const variance = await this.calculateVariance(deviceId, stat.data_type, timeRange);\n          const trend = await this.calculateTrend(deviceId, stat.data_type, timeRange);\n\n          return {\n            ...stat,\n            variance,\n            std_deviation: Math.sqrt(variance),\n            trend_direction: trend.direction,\n            trend_rate: trend.rate,\n            efficiency_score: this.calculateEfficiencyScore(stat)\n          };\n        })\n      );\n\n      this.setCache(cacheKey, enrichedStats);\n      return enrichedStats;\n    } catch (error) {\n      logger.error('è·å–è®¾å¤‡èƒ½æºç»Ÿè®¡å¤±è´¥:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * è·å–å›­åŒºæ•´ä½“èƒ½æºæ¶ˆè€—è¶‹åŠ¿\n   */\n  async getParkEnergyTrend(parkId, timeRange = '7d', interval = 'hour') {\n    try {\n      const cacheKey = `park_trend_${parkId}_${timeRange}_${interval}`;\n      const cached = this.getFromCache(cacheKey);\n      if (cached) {return cached;}\n\n      const timeCondition = this.getTimeCondition(timeRange);\n      const groupBy = this.getGroupByInterval(interval);\n\n      const sql = `\n        SELECT \n          ${groupBy} as time_period,\n          ed.data_type,\n          SUM(ed.value) as total_consumption,\n          AVG(ed.value) as avg_consumption,\n          COUNT(DISTINCT ed.device_id) as active_devices,\n          ed.unit\n        FROM energy_data ed\n        JOIN devices d ON ed.device_id = d.id\n        JOIN buildings b ON d.building_id = b.id\n        WHERE b.park_id = ? AND ed.timestamp >= datetime('now', ?)\n        GROUP BY time_period, ed.data_type, ed.unit\n        ORDER BY time_period, ed.data_type\n      `;\n\n      const trendData = await this.queryDatabase(sql, [parkId, timeCondition]);\n\n      // æŒ‰æ•°æ®ç±»å‹åˆ†ç»„\n      const groupedData = this.groupByDataType(trendData);\n\n      // è®¡ç®—è¶‹åŠ¿æŒ‡æ ‡\n      const trendsWithMetrics = {};\n      for (const [dataType, data] of Object.entries(groupedData)) {\n        trendsWithMetrics[dataType] = {\n          data,\n          metrics: this.calculateTrendMetrics(data)\n        };\n      }\n\n      this.setCache(cacheKey, trendsWithMetrics);\n      return trendsWithMetrics;\n    } catch (error) {\n      logger.error('è·å–å›­åŒºèƒ½æºè¶‹åŠ¿å¤±è´¥:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * ç”Ÿæˆèƒ½æºæ¶ˆè€—æŠ¥å‘Š\n   */\n  async generateEnergyReport(params) {\n    try {\n      const {\n        scope, // 'device', 'building', 'park'\n        scopeId,\n        timeRange = '30d',\n        includeComparison = true,\n        includeForecasting = false\n      } = params;\n\n      const report = {\n        id: uuidv4(),\n        scope,\n        scope_id: scopeId,\n        time_range: timeRange,\n        generated_at: new Date().toISOString(),\n        summary: {},\n        details: {},\n        recommendations: []\n      };\n\n      // è·å–åŸºç¡€ç»Ÿè®¡æ•°æ®\n      switch (scope) {\n        case 'device':\n          report.summary = await this.getDeviceEnergyStats(scopeId, timeRange);\n          break;\n        case 'building':\n          report.summary = await this.getBuildingEnergyStats(scopeId, timeRange);\n          break;\n        case 'park':\n          report.summary = await this.getParkEnergyStats(scopeId, timeRange);\n          break;\n      }\n\n      // æ·»åŠ å¯¹æ¯”åˆ†æ\n      if (includeComparison) {\n        report.comparison = await this.getComparisonData(scope, scopeId, timeRange);\n      }\n\n      // æ·»åŠ é¢„æµ‹åˆ†æ\n      if (includeForecasting) {\n        report.forecast = await this.generateForecast(scope, scopeId);\n      }\n\n      // ç”Ÿæˆå»ºè®®\n      report.recommendations = await this.generateRecommendations(report.summary);\n\n      // ä¿å­˜æŠ¥å‘Š\n      await this.saveReport(report);\n\n      return report;\n    } catch (error) {\n      logger.error('ç”Ÿæˆèƒ½æºæŠ¥å‘Šå¤±è´¥:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * è®¡ç®—èƒ½æºæ•ˆç‡è¯„åˆ†\n   */\n  async calculateEnergyEfficiency(scopeId, scope = 'building') {\n    try {\n      const baselineData = await this.getBaselineConsumption(scopeId, scope);\n      const currentData = await this.getCurrentConsumption(scopeId, scope);\n\n      if (!baselineData || !currentData) {\n        return { score: null, message: 'æ•°æ®ä¸è¶³ï¼Œæ— æ³•è®¡ç®—æ•ˆç‡è¯„åˆ†' };\n      }\n\n      // è®¡ç®—æ•ˆç‡è¯„åˆ† (0-100)\n      const efficiency = (baselineData.total - currentData.total) / baselineData.total;\n      const score = Math.max(MATH_CONSTANTS.ZERO, Math.min(MATH_CONSTANTS.ONE_HUNDRED, MATH_CONSTANTS.FIFTY + efficiency * MATH_CONSTANTS.FIFTY));\n\n      const result = {\n        score: Math.round(score),\n        baseline_consumption: baselineData.total,\n        current_consumption: currentData.total,\n        improvement: efficiency,\n        rating: this.getEfficiencyRating(score)\n      };\n\n      return result;\n    } catch (error) {\n      logger.error('è®¡ç®—èƒ½æºæ•ˆç‡å¤±è´¥:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * æ£€æµ‹èƒ½æºæ¶ˆè€—å¼‚å¸¸\n   */\n  async detectEnergyAnomalies(deviceId, timeRange = '7d') {\n    try {\n      const sql = `\n        SELECT \n          id,\n          device_id,\n          data_type,\n          value,\n          unit,\n          timestamp,\n          is_anomaly,\n          anomaly_reason\n        FROM energy_data \n        WHERE device_id = ? \n          AND timestamp >= datetime('now', ?)\n          AND (is_anomaly = 1 OR value > (\n            SELECT AVG(value) + 3 * (\n              SELECT SQRT(AVG((value - sub.avg_val) * (value - sub.avg_val)))\n              FROM (\n                SELECT AVG(value) as avg_val \n                FROM energy_data \n                WHERE device_id = ? AND data_type = energy_data.data_type\n              ) sub\n            )\n            FROM energy_data \n            WHERE device_id = ? AND data_type = energy_data.data_type\n          ))\n        ORDER BY timestamp DESC\n      `;\n\n      const timeCondition = this.getTimeCondition(timeRange);\n      const anomalies = await this.queryDatabase(sql, [\n        deviceId,\n        timeCondition,\n        deviceId,\n        deviceId\n      ]);\n\n      // åˆ†æå¼‚å¸¸æ¨¡å¼\n      const patterns = this.analyzeAnomalyPatterns(anomalies);\n\n      return {\n        anomalies,\n        patterns,\n        summary: {\n          total_anomalies: anomalies.length,\n          anomaly_rate: anomalies.length / (await this.getTotalDataPoints(deviceId, timeRange)),\n          most_common_type: patterns.mostCommonType,\n          severity_distribution: patterns.severityDistribution\n        }\n      };\n    } catch (error) {\n      logger.error('æ£€æµ‹èƒ½æºå¼‚å¸¸å¤±è´¥:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * è·å–èƒ½æºæˆæœ¬åˆ†æ\n   */\n  async getEnergyCostAnalysis(scopeId, scope = 'building', timeRange = '30d') {\n    try {\n      // è·å–èƒ½æºæ¶ˆè€—æ•°æ®\n      const consumptionData = await this.getEnergyConsumption(scopeId, scope, timeRange);\n\n      // è·å–èƒ½æºä»·æ ¼é…ç½®\n      const energyPrices = await this.getEnergyPrices();\n\n      // è®¡ç®—æˆæœ¬\n      const costAnalysis = {\n        total_cost: 0,\n        cost_breakdown: {},\n        cost_trends: [],\n        savings_opportunities: []\n      };\n\n      for (const [energyType, consumption] of Object.entries(consumptionData)) {\n        const price = energyPrices[energyType] || 0;\n        const cost = consumption.total * price;\n\n        costAnalysis.total_cost += cost;\n        costAnalysis.cost_breakdown[energyType] = {\n          consumption: consumption.total,\n          unit_price: price,\n          total_cost: cost,\n          percentage: 0 // å°†åœ¨åé¢è®¡ç®—\n        };\n      }\n\n      // è®¡ç®—ç™¾åˆ†æ¯”\n      for (const energyType of Object.keys(costAnalysis.cost_breakdown)) {\n        costAnalysis.cost_breakdown[energyType].percentage =\n          (costAnalysis.cost_breakdown[energyType].total_cost / costAnalysis.total_cost) * MATH_CONSTANTS.ONE_HUNDRED;\n      }\n\n      // è¯†åˆ«èŠ‚çº¦æœºä¼š\n      costAnalysis.savings_opportunities = await this.identifySavingsOpportunities(\n        consumptionData,\n        energyPrices\n      );\n\n      return costAnalysis;\n    } catch (error) {\n      logger.error('è·å–èƒ½æºæˆæœ¬åˆ†æå¤±è´¥:', error);\n      throw error;\n    }\n  }\n\n  // ==================== è¾…åŠ©æ–¹æ³• ====================\n\n  /**\n   * è·å–æ—¶é—´æ¡ä»¶\n   */\n  getTimeCondition(timeRange) {\n    const conditions = {\n      '1h': TIME_CONDITIONS.ONE_HOUR,\n      '6h': TIME_CONDITIONS.SIX_HOURS,\n      '24h': TIME_CONDITIONS.ONE_DAY,\n      '7d': TIME_CONDITIONS.SEVEN_DAYS,\n      '30d': TIME_CONDITIONS.THIRTY_DAYS,\n      '90d': TIME_CONDITIONS.NINETY_DAYS,\n      '1y': TIME_CONDITIONS.ONE_YEAR\n    };\n    return conditions[timeRange] || TIME_CONDITIONS.ONE_DAY;\n  }\n\n  /**\n   * è·å–åˆ†ç»„é—´éš”\n   */\n  getGroupByInterval(interval) {\n    const intervals = {\n      minute: \"strftime('%Y-%m-%d %H:%M', timestamp)\",\n      hour: \"strftime('%Y-%m-%d %H:00', timestamp)\",\n      day: \"strftime('%Y-%m-%d', timestamp)\",\n      week: \"strftime('%Y-W%W', timestamp)\",\n      month: \"strftime('%Y-%m', timestamp)\"\n    };\n    return intervals[interval] || intervals.hour;\n  }\n\n  /**\n   * æŒ‰æ•°æ®ç±»å‹åˆ†ç»„\n   */\n  groupByDataType(data) {\n    return data.reduce((groups, item) => {\n      const key = `${item.data_type}_${item.unit}`;\n      if (!groups[key]) {\n        groups[key] = [];\n      }\n      groups[key].push(item);\n      return groups;\n    }, {});\n  }\n\n  /**\n   * è®¡ç®—è¶‹åŠ¿æŒ‡æ ‡\n   */\n\n  // TODO: è€ƒè™‘å°†æ­¤å‡½æ•°æ‹†åˆ†ä¸ºæ›´å°çš„å‡½æ•° (å½“å‰ 22 è¡Œ)\n\n  // TODO: è€ƒè™‘å°†æ­¤å‡½æ•°æ‹†åˆ†ä¸ºæ›´å°çš„å‡½æ•° (å½“å‰ 22 è¡Œ)\n\n  // TODO: è€ƒè™‘å°†æ­¤å‡½æ•°æ‹†åˆ†ä¸ºæ›´å°çš„å‡½æ•° (å½“å‰ 22 è¡Œ)\n\n  // TODO: è€ƒè™‘å°†æ­¤å‡½æ•°æ‹†åˆ†ä¸ºæ›´å°çš„å‡½æ•° (å½“å‰ 22 è¡Œ)\n\n  calculateTrendMetrics(data) {\n    if (!(data.length < 2)) {\n      return { direction: 'stable', rate: 0, correlation: 0 };\n    }\n\n    const values = data.map(d => d.total_consumption);\n    const n = values.length;\n\n    // è®¡ç®—çº¿æ€§å›å½’æ–œç‡\n    const sumX = (n * (n - MATH_CONSTANTS.ONE)) / MATH_CONSTANTS.TWO;\n    const sumY = values.reduce((sum, val) => sum + val, 0);\n    const sumXY = values.reduce((sum, val, idx) => sum + val * idx, 0);\n    const sumX2 = (n * (n - MATH_CONSTANTS.ONE) * (MATH_CONSTANTS.TWO * n - MATH_CONSTANTS.ONE)) / MATH_CONSTANTS.SIX;\n\n    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n\n    return {\n      direction: slope > MATH_CONSTANTS.TEN_PERCENT ? 'increasing' : slope < -MATH_CONSTANTS.TEN_PERCENT ? 'decreasing' : 'stable',\n      rate: Math.abs(slope),\n      correlation: this.calculateCorrelation(values)\n    };\n  }\n\n  /**\n   * è®¡ç®—ç›¸å…³ç³»æ•°\n   */\n  calculateCorrelation(values) {\n    const n = values.length;\n    const indices = Array.from({ length: n }, (_, i) => i);\n\n    const meanX = (n - MATH_CONSTANTS.ONE) / MATH_CONSTANTS.TWO;\n    const meanY = values.reduce((sum, val) => sum + val, 0) / n;\n\n    const numerator = indices.reduce((sum, x, i) => sum + (x - meanX) * (values[i] - meanY), 0);\n\n    const denomX = Math.sqrt(indices.reduce((sum, x) => sum + Math.pow(x - meanX, 2), 0));\n    const denomY = Math.sqrt(values.reduce((sum, y) => sum + Math.pow(y - meanY, 2), 0));\n\n    return denomX * denomY === MATH_CONSTANTS.ZERO ? MATH_CONSTANTS.ZERO : numerator / (denomX * denomY);\n  }\n\n  /**\n   * è®¡ç®—æ–¹å·®\n   */\n  async calculateVariance(deviceId, dataType, timeRange) {\n    const sql = `\n      SELECT AVG(value) as mean, COUNT(*) as count\n      FROM energy_data \n      WHERE device_id = ? AND data_type = ? AND timestamp >= datetime('now', ?)\n    `;\n\n    const timeCondition = this.getTimeCondition(timeRange);\n    const result = await this.queryDatabase(sql, [deviceId, dataType, timeCondition]);\n\n    const [firstResult] = result;\n    if (!firstResult || firstResult.count === 0) {return 0;}\n\n    const { mean } = firstResult;\n\n    const varianceSql = `\n      SELECT AVG((value - ?) * (value - ?)) as variance\n      FROM energy_data \n      WHERE device_id = ? AND data_type = ? AND timestamp >= datetime('now', ?)\n    `;\n\n    const varianceResult = await this.queryDatabase(varianceSql, [\n      mean,\n      mean,\n      deviceId,\n      dataType,\n      timeCondition\n    ]);\n    return varianceResult[0]?.variance || 0;\n  }\n\n  /**\n   * è®¡ç®—è¶‹åŠ¿\n   */\n  async calculateTrend(deviceId, dataType, timeRange) {\n    const sql = `\n      SELECT value, timestamp\n      FROM energy_data \n      WHERE device_id = ? AND data_type = ? AND timestamp >= datetime('now', ?)\n      ORDER BY timestamp\n    `;\n\n    const timeCondition = this.getTimeCondition(timeRange);\n    const data = await this.queryDatabase(sql, [deviceId, dataType, timeCondition]);\n\n    if (data.length < 2) {\n      return { direction: 'stable', rate: 0 };\n    }\n\n    const [firstItem] = data;\n    const lastItem = data[data.length - 1];\n    const firstValue = firstItem.value;\n    const lastValue = lastItem.value;\n    const change = (lastValue - firstValue) / firstValue;\n\n    return {\n      direction: change > ANOMALY_THRESHOLDS.CHANGE_THRESHOLD ? 'increasing' : change < -ANOMALY_THRESHOLDS.CHANGE_THRESHOLD ? 'decreasing' : 'stable',\n      rate: Math.abs(change)\n    };\n  }\n\n  /**\n   * è®¡ç®—æ•ˆç‡è¯„åˆ†\n   */\n  calculateEfficiencyScore(stat) {\n    // åŸºäºæ•°æ®è´¨é‡ã€å˜å¼‚ç³»æ•°ç­‰è®¡ç®—æ•ˆç‡è¯„åˆ†\n    const cv = stat.avg_value > 0 ? Math.sqrt(stat.variance || 0) / stat.avg_value : 0;\n    const score = Math.max(MATH_CONSTANTS.ZERO, Math.min(MATH_CONSTANTS.ONE_HUNDRED, MATH_CONSTANTS.ONE_HUNDRED - cv * MATH_CONSTANTS.ONE_HUNDRED));\n    return Math.round(score);\n  }\n\n  /**\n   * è·å–æ•ˆç‡ç­‰çº§\n   */\n  getEfficiencyRating(score) {\n    if (score >= EFFICIENCY_THRESHOLDS.EXCELLENT) {return 'A+';}\n    if (score >= EFFICIENCY_THRESHOLDS.GOOD) {return 'A';}\n    if (score >= EFFICIENCY_THRESHOLDS.AVERAGE) {return 'B';}\n    if (score >= EFFICIENCY_THRESHOLDS.POOR) {return 'C';}\n    if (score >= EFFICIENCY_THRESHOLDS.VERY_POOR) {return 'D';}\n    return 'F';\n  }\n\n  /**\n   * ç¼“å­˜ç®¡ç†\n   */\n  getFromCache(key) {\n    const cached = this.cache.get(key);\n    // TODO: è€ƒè™‘ä½¿ç”¨æ—©æœŸè¿”å›æˆ–ç­–ç•¥æ¨¡å¼æ¥å‡å°‘åµŒå¥—\n    // TODO: è€ƒè™‘ä½¿ç”¨æ—©æœŸè¿”å›æˆ–ç­–ç•¥æ¨¡å¼æ¥å‡å°‘åµŒå¥—\n    // TODO: è€ƒè™‘ä½¿ç”¨æ—©æœŸè¿”å›æˆ–ç­–ç•¥æ¨¡å¼æ¥å‡å°‘åµŒå¥—\n    // TODO: è€ƒè™‘ä½¿ç”¨æ—©æœŸè¿”å›æˆ–ç­–ç•¥æ¨¡å¼æ¥å‡å°‘åµŒå¥—\n    // TODO: è€ƒè™‘ä½¿ç”¨æ—©æœŸè¿”å›æˆ–ç­–ç•¥æ¨¡å¼æ¥å‡å°‘åµŒå¥—\n    // TODO: è€ƒè™‘ä½¿ç”¨æ—©æœŸè¿”å›æˆ–ç­–ç•¥æ¨¡å¼æ¥å‡å°‘åµŒå¥—\n    // TODO: è€ƒè™‘ä½¿ç”¨æ—©æœŸè¿”å›æˆ–ç­–ç•¥æ¨¡å¼æ¥å‡å°‘åµŒå¥—\n    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {\n      return cached.data;\n    }\n    return null;\n  }\n\n  setCache(key, data) {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now()\n    });\n  }\n\n  /**\n   * æ•°æ®åº“æŸ¥è¯¢å°è£…\n   */\n  queryDatabase(sql, params = []) {\n    return new Promise((resolve, reject) => {\n      dbPromise\n        .then(db => {\n          db.raw(sql, params).then(rows => {\n            resolve(rows || []);\n          }).catch(err => {\n            reject(err);\n          });\n        })\n        .catch(reject);\n    });\n  }\n\n  /**\n   * è·å–å»ºç­‘èƒ½æºç»Ÿè®¡\n   */\n  async getBuildingEnergyStats(buildingId, timeRange = '24h') {\n    try {\n      const cacheKey = `building_stats_${buildingId}_${timeRange}`;\n      const cached = this.getFromCache(cacheKey);\n      if (cached) {return cached;}\n\n      const timeCondition = this.getTimeCondition(timeRange);\n\n      const sql = `\n        SELECT \n          ed.data_type,\n          COUNT(*) as data_points,\n          AVG(ed.value) as avg_value,\n          MIN(ed.value) as min_value,\n          MAX(ed.value) as max_value,\n          SUM(ed.value) as total_value,\n          ed.unit,\n          COUNT(DISTINCT ed.device_id) as device_count\n        FROM energy_data ed\n        JOIN devices d ON ed.device_id = d.id\n        WHERE d.building_id = ? AND ed.timestamp >= datetime('now', ?)\n        GROUP BY ed.data_type, ed.unit\n        ORDER BY ed.data_type\n      `;\n\n      const stats = await this.queryDatabase(sql, [buildingId, timeCondition]);\n      this.setCache(cacheKey, stats);\n      return stats;\n    } catch (error) {\n      logger.error('è·å–å»ºç­‘èƒ½æºç»Ÿè®¡å¤±è´¥:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * è·å–å›­åŒºèƒ½æºç»Ÿè®¡\n   */\n  async getParkEnergyStats(parkId, timeRange = '24h') {\n    try {\n      const cacheKey = `park_stats_${parkId}_${timeRange}`;\n      const cached = this.getFromCache(cacheKey);\n      if (cached) {return cached;}\n\n      const timeCondition = this.getTimeCondition(timeRange);\n\n      const sql = `\n        SELECT \n          ed.data_type,\n          COUNT(*) as data_points,\n          AVG(ed.value) as avg_value,\n          MIN(ed.value) as min_value,\n          MAX(ed.value) as max_value,\n          SUM(ed.value) as total_value,\n          ed.unit,\n          COUNT(DISTINCT ed.device_id) as device_count,\n          COUNT(DISTINCT d.building_id) as building_count\n        FROM energy_data ed\n        JOIN devices d ON ed.device_id = d.id\n        JOIN buildings b ON d.building_id = b.id\n        WHERE b.park_id = ? AND ed.timestamp >= datetime('now', ?)\n        GROUP BY ed.data_type, ed.unit\n        ORDER BY ed.data_type\n      `;\n\n      const stats = await this.queryDatabase(sql, [parkId, timeCondition]);\n      this.setCache(cacheKey, stats);\n      return stats;\n    } catch (error) {\n      logger.error('è·å–å›­åŒºèƒ½æºç»Ÿè®¡å¤±è´¥:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * è·å–å¯¹æ¯”æ•°æ®\n   */\n  async getComparisonData(scope, scopeId, timeRange) {\n    try {\n      // è·å–å½“å‰å‘¨æœŸæ•°æ®\n      const currentData = await this.getEnergyConsumption(scopeId, scope, timeRange);\n\n      // è·å–ä¸Šä¸€ä¸ªå‘¨æœŸæ•°æ®\n      const previousTimeRange = this.getPreviousTimeRange(timeRange);\n      const previousData = await this.getEnergyConsumption(\n        scopeId,\n        scope,\n        timeRange,\n        previousTimeRange\n      );\n\n      // è®¡ç®—å¯¹æ¯”æŒ‡æ ‡\n      const comparison = {};\n      for (const [energyType, current] of Object.entries(currentData)) {\n        const previous = previousData[energyType];\n        if (previous) {\n          const change = (current.total - previous.total) / previous.total;\n          comparison[energyType] = {\n            current: current.total,\n            previous: previous.total,\n            change,\n            change_percentage: change * 100,\n            trend: change > ANOMALY_THRESHOLDS.CHANGE_THRESHOLD ? 'increasing' : change < -ANOMALY_THRESHOLDS.CHANGE_THRESHOLD ? 'decreasing' : 'stable'\n          };\n        } else {\n          comparison[energyType] = {\n            current: current.total,\n            previous: 0,\n            change: null,\n            change_percentage: null,\n            trend: 'new'\n          };\n        }\n      }\n\n      return comparison;\n    } catch (error) {\n      logger.error('è·å–å¯¹æ¯”æ•°æ®å¤±è´¥:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * ç”Ÿæˆé¢„æµ‹\n   */\n  async generateForecast(scope, scopeId) {\n    try {\n      // è·å–å†å²æ•°æ®ç”¨äºé¢„æµ‹\n      const historicalData = await this.getHistoricalData(scopeId, scope, '90d');\n\n      const forecast = {};\n      for (const [energyType, data] of Object.entries(historicalData)) {\n        if (data.length < MATH_CONSTANTS.SEVEN) {\n          forecast[energyType] = {\n            message: 'æ•°æ®ä¸è¶³ï¼Œæ— æ³•ç”Ÿæˆé¢„æµ‹',\n            confidence: 0\n          };\n          continue;\n        }\n\n        // ç®€å•çš„çº¿æ€§å›å½’é¢„æµ‹\n        const trend = this.calculateLinearTrend(data);\n        const nextPeriodForecast = this.extrapolateTrend(trend, MATH_CONSTANTS.SEVEN); // é¢„æµ‹æœªæ¥7å¤©\n\n        forecast[energyType] = {\n          trend_direction: trend.direction,\n          predicted_values: nextPeriodForecast,\n          confidence: this.calculateForecastConfidence(data, trend),\n          method: 'linear_regression'\n        };\n      }\n\n      return forecast;\n    } catch (error) {\n      logger.error('ç”Ÿæˆé¢„æµ‹å¤±è´¥:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * ç”Ÿæˆå»ºè®®\n   */\n  async generateRecommendations(summary) {\n    const recommendations = [];\n\n    try {\n      for (const stat of summary) {\n        // åŸºäºæ•ˆç‡è¯„åˆ†ç”Ÿæˆå»ºè®®\n        if (stat.efficiency_score < EFFICIENCY_THRESHOLDS.POOR) {\n          recommendations.push({\n            type: 'efficiency',\n            priority: 'high',\n            title: `${stat.data_type}èƒ½æºæ•ˆç‡åä½`,\n            description: `å½“å‰æ•ˆç‡è¯„åˆ†ä¸º${stat.efficiency_score}åˆ†ï¼Œå»ºè®®æ£€æŸ¥è®¾å¤‡è¿è¡ŒçŠ¶æ€å’Œä¼˜åŒ–é…ç½®`,\n            potential_savings: this.estimatePotentialSavings(stat)\n          });\n        }\n\n        // åŸºäºè¶‹åŠ¿ç”Ÿæˆå»ºè®®\n        if (stat.trend_direction === 'increasing' && stat.trend_rate > MATH_CONSTANTS.TWENTY_PERCENT) {\n          recommendations.push({\n            type: 'trend',\n            priority: 'medium',\n            title: `${stat.data_type}æ¶ˆè€—å‘ˆä¸Šå‡è¶‹åŠ¿`,\n            description: `æ¶ˆè€—é‡å¢é•¿ç‡ä¸º${(stat.trend_rate * 100).toFixed(1)}%ï¼Œå»ºè®®å…³æ³¨ä½¿ç”¨æ¨¡å¼å˜åŒ–`,\n            potential_savings: null\n          });\n        }\n\n        // åŸºäºå˜å¼‚ç³»æ•°ç”Ÿæˆå»ºè®®\n        if (stat.std_deviation / stat.avg_value > MATH_CONSTANTS.FIFTY_PERCENT) {\n          recommendations.push({\n            type: 'stability',\n            priority: 'low',\n            title: `${stat.data_type}æ¶ˆè€—æ³¢åŠ¨è¾ƒå¤§`,\n            description: 'èƒ½æºæ¶ˆè€—ä¸ç¨³å®šï¼Œå»ºè®®æ£€æŸ¥è®¾å¤‡è¿è¡Œè§„å¾‹å’Œè´Ÿè½½ç®¡ç†',\n            potential_savings: null\n          });\n        }\n      }\n\n      return recommendations;\n    } catch (error) {\n      logger.error('ç”Ÿæˆå»ºè®®å¤±è´¥:', error);\n      return [];\n    }\n  }\n\n  /**\n   * è·å–èƒ½æºæ¶ˆè€—æ•°æ®\n   */\n  async getEnergyConsumption(scopeId, scope, timeRange, customTimeRange = null) {\n    try {\n\n  // TODO: è€ƒè™‘å°†æ­¤å‡½æ•°æ‹†åˆ†ä¸ºæ›´å°çš„å‡½æ•° (å½“å‰ 37 è¡Œ)\n\n  // TODO: è€ƒè™‘å°†æ­¤å‡½æ•°æ‹†åˆ†ä¸ºæ›´å°çš„å‡½æ•° (å½“å‰ 37 è¡Œ)\n\n  // TODO: è€ƒè™‘å°†æ­¤å‡½æ•°æ‹†åˆ†ä¸ºæ›´å°çš„å‡½æ•° (å½“å‰ 37 è¡Œ)\n\n  // TODO: è€ƒè™‘å°†æ­¤å‡½æ•°æ‹†åˆ†ä¸ºæ›´å°çš„å‡½æ•° (å½“å‰ 37 è¡Œ)\n\n      const timeCondition = customTimeRange || this.getTimeCondition(timeRange);\n      let sql; let params;\n\n      switch (scope) {\n        case 'device':\n          sql = `\n            SELECT data_type, SUM(value) as total, unit\n            FROM energy_data \n            WHERE device_id = ? AND timestamp >= datetime('now', ?)\n            GROUP BY data_type, unit\n          `;\n          params = [scopeId, timeCondition];\n          break;\n\n        case 'building':\n          sql = `\n            SELECT ed.data_type, SUM(ed.value) as total, ed.unit\n            FROM energy_data ed\n            JOIN devices d ON ed.device_id = d.id\n            WHERE d.building_id = ? AND ed.timestamp >= datetime('now', ?)\n            GROUP BY ed.data_type, ed.unit\n          `;\n          params = [scopeId, timeCondition];\n          break;\n\n        case 'park':\n          sql = `\n            SELECT ed.data_type, SUM(ed.value) as total, ed.unit\n            FROM energy_data ed\n            JOIN devices d ON ed.device_id = d.id\n            JOIN buildings b ON d.building_id = b.id\n            WHERE b.park_id = ? AND ed.timestamp >= datetime('now', ?)\n            GROUP BY ed.data_type, ed.unit\n          `;\n          params = [scopeId, timeCondition];\n          break;\n\n        default:\n          throw new Error('æ— æ•ˆçš„scopeå‚æ•°');\n      }\n\n      const data = await this.queryDatabase(sql, params);\n\n      // è½¬æ¢ä¸ºå¯¹è±¡æ ¼å¼\n      const consumption = {};\n      data.forEach(item => {\n        const key = `${item.data_type}_${item.unit}`;\n        consumption[key] = {\n          total: item.total,\n          unit: item.unit\n        };\n      });\n\n      return consumption;\n    } catch (error) {\n      logger.error('è·å–èƒ½æºæ¶ˆè€—æ•°æ®å¤±è´¥:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * è·å–èƒ½æºä»·æ ¼\n   */\n  async getEnergyPrices() {\n    try {\n      const sql = `\n        SELECT energy_type, price, unit\n        FROM energy_prices \n        WHERE is_active = 1\n        ORDER BY effective_date DESC\n      `;\n\n      const prices = await this.queryDatabase(sql);\n\n      // è½¬æ¢ä¸ºå¯¹è±¡æ ¼å¼\n      const priceMap = {};\n      prices.forEach(price => {\n        priceMap[`${price.energy_type}_${price.unit}`] = price.price;\n      });\n\n      // å¦‚æœæ²¡æœ‰é…ç½®ä»·æ ¼ï¼Œä½¿ç”¨é»˜è®¤å€¼\n      if (!(Object.keys(priceMap).length === 0)) {\n        return {\n          electricity_kWh: 0.8,\n          water_m3: 3.5,\n          gas_m3: 2.8\n        };\n      }\n\n      return priceMap;\n    } catch (error) {\n      logger.error('è·å–èƒ½æºä»·æ ¼å¤±è´¥:', error);\n      return {};\n    }\n  }\n\n  /**\n   * è¯†åˆ«èŠ‚çº¦æœºä¼š\n   */\n  async identifySavingsOpportunities(consumptionData, energyPrices) {\n    const opportunities = [];\n\n    try {\n      for (const [energyType, consumption] of Object.entries(consumptionData)) {\n        const price = energyPrices[energyType] || 0;\n        const _currentCost = consumption.total * price;\n\n        // åŸºäºè¡Œä¸šåŸºå‡†è¯†åˆ«èŠ‚çº¦æœºä¼š\n        const benchmark = await this.getIndustryBenchmark(energyType);\n        if (benchmark && consumption.total > benchmark.average * MATH_CONSTANTS.ONE_POINT_TWO) {\n          const potentialSaving = (consumption.total - benchmark.average) * price;\n          opportunities.push({\n            energy_type: energyType,\n            current_consumption: consumption.total,\n            benchmark_average: benchmark.average,\n            excess_consumption: consumption.total - benchmark.average,\n            potential_cost_saving: potentialSaving,\n            recommendation: `${energyType}æ¶ˆè€—è¶…å‡ºè¡Œä¸šå¹³å‡æ°´å¹³20%ï¼Œå»ºè®®ä¼˜åŒ–ä½¿ç”¨ç­–ç•¥`\n          });\n        }\n      }\n\n      return opportunities;\n    } catch (error) {\n      logger.error('è¯†åˆ«èŠ‚çº¦æœºä¼šå¤±è´¥:', error);\n      return [];\n    }\n  }\n\n  /**\n   * è·å–åŸºå‡†æ¶ˆè€—\n   */\n  async getBaselineConsumption(scopeId, scope) {\n    try {\n      const sql = `\n        SELECT SUM(baseline_value) as total\n        FROM baseline_consumption \n        WHERE scope = ? AND scope_id = ?\n      `;\n\n      const result = await this.queryDatabase(sql, [scope, scopeId]);\n      return result[0] || null;\n    } catch (error) {\n      logger.error('è·å–åŸºå‡†æ¶ˆè€—å¤±è´¥:', error);\n      return null;\n    }\n  }\n\n  /**\n   * è·å–å½“å‰æ¶ˆè€—\n   */\n  async getCurrentConsumption(scopeId, scope) {\n    try {\n      const consumption = await this.getEnergyConsumption(scopeId, scope, '30d');\n      const total = Object.values(consumption).reduce((sum, item) => sum + item.total, 0);\n      return { total };\n    } catch (error) {\n      logger.error('è·å–å½“å‰æ¶ˆè€—å¤±è´¥:', error);\n      return null;\n    }\n  }\n\n  /**\n   * è·å–è¡Œä¸šåŸºå‡†\n   */\n  async getIndustryBenchmark(energyType) {\n    // è¿™é‡Œå¯ä»¥ä»å¤–éƒ¨æ•°æ®æºè·å–è¡Œä¸šåŸºå‡†æ•°æ®\n    // æš‚æ—¶è¿”å›æ¨¡æ‹Ÿæ•°æ®\n    const benchmarks = {\n      electricity_kWh: { average: 1000, unit: 'kWh' },\n      water_m3: { average: 50, unit: 'm3' },\n      gas_m3: { average: 100, unit: 'm3' }\n    };\n\n    return benchmarks[energyType] || null;\n  }\n\n  /**\n   * è·å–å†å²æ•°æ®\n   */\n  async getHistoricalData(scopeId, scope, timeRange) {\n    try {\n      const _consumption = await this.getEnergyConsumption(scopeId, scope, timeRange);\n\n      // æŒ‰å¤©åˆ†ç»„è·å–è¯¦ç»†å†å²æ•°æ®\n      const timeCondition = this.getTimeCondition(timeRange);\n      let sql; let params;\n\n      switch (scope) {\n        case 'device':\n          sql = `\n            SELECT \n              strftime('%Y-%m-%d', timestamp) as date,\n              data_type,\n              SUM(value) as daily_total\n            FROM energy_data \n            WHERE device_id = ? AND timestamp >= datetime('now', ?)\n            GROUP BY date, data_type\n            ORDER BY date\n          `;\n          params = [scopeId, timeCondition];\n          break;\n\n        default:\n          // å…¶ä»–scopeçš„å®ç°ç±»ä¼¼\n          return {};\n      }\n\n      const data = await this.queryDatabase(sql, params);\n\n      // æŒ‰æ•°æ®ç±»å‹åˆ†ç»„\n      const grouped = {};\n      data.forEach(item => {\n        if (!grouped[item.data_type]) {\n          grouped[item.data_type] = [];\n        }\n        grouped[item.data_type].push({\n          date: item.date,\n          value: item.daily_total\n        });\n      });\n\n      return grouped;\n    } catch (error) {\n      logger.error('è·å–å†å²æ•°æ®å¤±è´¥:', error);\n      return {};\n    }\n  }\n\n  /**\n   * è®¡ç®—çº¿æ€§è¶‹åŠ¿\n   */\n  calculateLinearTrend(data) {\n    if (data.length < 2) {\n      return { direction: 'stable', slope: 0, intercept: 0 };\n    }\n\n    const n = data.length;\n    const sumX = (n * (n - MATH_CONSTANTS.ONE)) / MATH_CONSTANTS.TWO;\n    const sumY = data.reduce((sum, item) => sum + item.value, MATH_CONSTANTS.ZERO);\n    const sumXY = data.reduce((sum, item, index) => sum + item.value * index, MATH_CONSTANTS.ZERO);\n    const sumX2 = (n * (n - MATH_CONSTANTS.ONE) * (MATH_CONSTANTS.TWO * n - MATH_CONSTANTS.ONE)) / MATH_CONSTANTS.SIX;\n\n    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n    const intercept = (sumY - slope * sumX) / n;\n\n    return {\n      direction: slope > MATH_CONSTANTS.TEN_PERCENT ? 'increasing' : slope < -MATH_CONSTANTS.TEN_PERCENT ? 'decreasing' : 'stable',\n      slope,\n      intercept\n    };\n  }\n\n  /**\n   * å¤–æ¨è¶‹åŠ¿\n   */\n  extrapolateTrend(trend, periods) {\n    const predictions = [];\n    const lastIndex = periods;\n\n    for (let i = 1; i <= periods; i++) {\n      const predictedValue = trend.intercept + trend.slope * (lastIndex + i);\n      predictions.push(Math.max(MATH_CONSTANTS.ZERO, predictedValue)); // ç¡®ä¿é¢„æµ‹å€¼ä¸ä¸ºè´Ÿ\n    }\n\n    return predictions;\n  }\n\n  /**\n   * è®¡ç®—é¢„æµ‹ç½®ä¿¡åº¦\n   */\n  calculateForecastConfidence(data, trend) {\n    if (data.length < MATH_CONSTANTS.THREE) {return MATH_CONSTANTS.ZERO;}\n\n    // è®¡ç®—RÂ²å€¼ä½œä¸ºç½®ä¿¡åº¦æŒ‡æ ‡\n    const actualValues = data.map(item => item.value);\n    const predictedValues = data.map((item, index) => trend.intercept + trend.slope * index);\n\n    const meanActual = actualValues.reduce((sum, val) => sum + val, MATH_CONSTANTS.ZERO) / actualValues.length;\n\n    const totalSumSquares = actualValues.reduce(\n      (sum, val) => sum + Math.pow(val - meanActual, MATH_CONSTANTS.TWO),\n      MATH_CONSTANTS.ZERO\n    );\n    const residualSumSquares = actualValues.reduce((sum, val, index) => sum + Math.pow(val - predictedValues[index], MATH_CONSTANTS.TWO), MATH_CONSTANTS.ZERO);\n\n    const rSquared = MATH_CONSTANTS.ONE - residualSumSquares / totalSumSquares;\n    return Math.max(MATH_CONSTANTS.ZERO, Math.min(MATH_CONSTANTS.ONE, rSquared)) * MATH_CONSTANTS.ONE_HUNDRED; // è½¬æ¢ä¸ºç™¾åˆ†æ¯”\n  }\n\n  /**\n   * è·å–ä¸Šä¸€ä¸ªæ—¶é—´èŒƒå›´\n   */\n  getPreviousTimeRange(timeRange) {\n    const ranges = {\n      '1h': PREVIOUS_TIME_RANGES.ONE_HOUR,\n      '6h': PREVIOUS_TIME_RANGES.SIX_HOURS,\n      '24h': PREVIOUS_TIME_RANGES.ONE_DAY,\n      '7d': PREVIOUS_TIME_RANGES.SEVEN_DAYS,\n      '30d': PREVIOUS_TIME_RANGES.THIRTY_DAYS,\n      '90d': PREVIOUS_TIME_RANGES.NINETY_DAYS,\n      '1y': PREVIOUS_TIME_RANGES.ONE_YEAR\n    };\n    return ranges[timeRange] || PREVIOUS_TIME_RANGES.ONE_DAY;\n  }\n\n  /**\n   * ä¼°ç®—æ½œåœ¨èŠ‚çº¦\n   */\n  estimatePotentialSavings(stat) {\n    // åŸºäºæ•ˆç‡è¯„åˆ†ä¼°ç®—æ½œåœ¨èŠ‚çº¦ç™¾åˆ†æ¯”\n    const efficiencyGap = (EFFICIENCY_THRESHOLDS.GOOD - stat.efficiency_score) / MATH_CONSTANTS.ONE_HUNDRED; // å‡è®¾80åˆ†ä¸ºè‰¯å¥½æ°´å¹³\n    const potentialSavingPercentage = Math.max(MATH_CONSTANTS.ZERO, efficiencyGap * MATH_CONSTANTS.THIRTY_PERCENT); // æœ€å¤š30%çš„èŠ‚çº¦æ½œåŠ›\n\n    return {\n      percentage: potentialSavingPercentage * MATH_CONSTANTS.ONE_HUNDRED,\n      estimated_amount: stat.total_value * potentialSavingPercentage\n    };\n  }\n\n  /**\n   * åˆ†æå¼‚å¸¸æ¨¡å¼\n   */\n  analyzeAnomalyPatterns(anomalies) {\n    const patterns = {\n      mostCommonType: null,\n      severityDistribution: {},\n      timePatterns: {},\n      devicePatterns: {}\n    };\n\n    if (anomalies.length === 0) {return patterns;}\n\n    // åˆ†ææœ€å¸¸è§çš„å¼‚å¸¸ç±»å‹\n    const typeCount = {};\n    anomalies.forEach(anomaly => {\n      const reason = anomaly.anomaly_reason || 'unknown';\n      typeCount[reason] = (typeCount[reason] || 0) + 1;\n    });\n\n    patterns.mostCommonType = Object.keys(typeCount).reduce((a, b) =>\n      (typeCount[a] > typeCount[b] ? a : b)\n    );\n\n    // åˆ†æä¸¥é‡ç¨‹åº¦åˆ†å¸ƒ\n    anomalies.forEach(anomaly => {\n      const severity = this.classifyAnomalySeverity(anomaly.value);\n      patterns.severityDistribution[severity] = (patterns.severityDistribution[severity] || 0) + 1;\n    });\n\n    return patterns;\n  }\n\n  /**\n   * åˆ†ç±»å¼‚å¸¸ä¸¥é‡ç¨‹åº¦\n   */\n  classifyAnomalySeverity(value) {\n    // ç®€å•çš„ä¸¥é‡ç¨‹åº¦åˆ†ç±»é€»è¾‘\n    if (value > MATH_CONSTANTS.ONE_THOUSAND) {return 'high';}\n    if (value > MATH_CONSTANTS.FIVE_HUNDRED) {return 'medium';}\n    return 'low';\n  }\n\n  /**\n   * è·å–æ€»æ•°æ®ç‚¹æ•°\n   */\n  async getTotalDataPoints(deviceId, timeRange) {\n    try {\n      const timeCondition = this.getTimeCondition(timeRange);\n      const sql = `\n        SELECT COUNT(*) as total\n        FROM energy_data \n        WHERE device_id = ? AND timestamp >= datetime('now', ?)\n      `;\n\n      const result = await this.queryDatabase(sql, [deviceId, timeCondition]);\n      return result[0]?.total || MATH_CONSTANTS.ZERO;\n    } catch (error) {\n      logger.error('è·å–æ€»æ•°æ®ç‚¹æ•°å¤±è´¥:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * ä¿å­˜æŠ¥å‘Š\n   */\n  async saveReport(report) {\n    const _sql = `\n      INSERT INTO energy_reports (\n        id, scope, scope_id, time_range, report_data, generated_at\n      ) VALUES (?, ?, ?, ?, ?, ?)\n    `;\n\n    // æ¨¡æ‹Ÿæ•°æ®åº“ä¿å­˜æ“ä½œ\n    return new Promise((resolve) => {\n      logger.info('æ¨¡æ‹Ÿä¿å­˜æŠ¥å‘Š:', report.id);\n      resolve(report.id);\n    });\n  }\n}\n\nexport default EnergyAnalytics;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]