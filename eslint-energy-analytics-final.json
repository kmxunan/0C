[{"filePath":"/Users/xunan/Documents/WebStormProjects/0C/src/core/services/EnergyAnalytics.js","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":681,"column":41,"nodeType":"Literal","messageId":"noMagic","endLine":681,"endColumn":44},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":764,"column":55,"nodeType":"Literal","messageId":"noMagic","endLine":764,"endColumn":58}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\n// 🚨 安全警告: 此文件包含SQL查询，请确保使用参数化查询防止SQL注入\n// 示例: db.query('SELECT * FROM users WHERE id = ?', [userId])\n// 避免: db.query('SELECT * FROM users WHERE id = ' + userId)\nimport { dbPromise } from '../../infrastructure/database/index.js';\nimport { v4 as uuidv4 } from 'uuid';\nimport { defaultLogger as logger } from '../../utils/logger.js';\nimport { MATH_CONSTANTS, TIME_INTERVALS, PREVIOUS_TIME_RANGES } from '../../shared/constants/MathConstants.js';\n// 常量定义\nconst EFFICIENCY_THRESHOLDS = {\n  EXCELLENT: MATH_CONSTANTS.NINETY,\n  GOOD: MATH_CONSTANTS.EIGHTY,\n  AVERAGE: MATH_CONSTANTS.SEVENTY,\n  POOR: MATH_CONSTANTS.SIXTY,\n  VERY_POOR: MATH_CONSTANTS.FIFTY\n};\n\nconst ANOMALY_THRESHOLDS = {\n  STANDARD_DEVIATIONS: MATH_CONSTANTS.THREE,\n  CHANGE_THRESHOLD: 0.05\n};\n\nconst TIME_CONDITIONS = {\n  ONE_HOUR: '-1 hour',\n  SIX_HOURS: '-6 hours',\n  ONE_DAY: '-1 day',\n  TWO_DAYS: '-2 days',\n  SEVEN_DAYS: '-7 days',\n  THIRTY_DAYS: '-30 days',\n  NINETY_DAYS: '-90 days',\n  ONE_YEAR: '-1 year'\n};\n\n/**\n * 能源分析模块\n * 提供能源数据的统计分析、趋势计算和报告生成功能\n */\nclass EnergyAnalytics {\n  constructor() {\n    this.cache = new Map();\n    this.cacheTimeout = TIME_INTERVALS.FIVE_MINUTES_MS; // 5分钟缓存\n  }\n\n  /**\n   * 获取设备能源消耗统计\n   */\n  async getDeviceEnergyStats(deviceId, timeRange = '24h') {\n    try {\n      const cacheKey = `device_stats_${deviceId}_${timeRange}`;\n      const cached = this.getFromCache(cacheKey);\n      if (cached) {return cached;}\n\n      const timeCondition = this.getTimeCondition(timeRange);\n\n      const sql = `\n        SELECT \n          data_type,\n          COUNT(*) as data_points,\n          AVG(value) as avg_value,\n          MIN(value) as min_value,\n          MAX(value) as max_value,\n          SUM(value) as total_value,\n          unit,\n          MIN(timestamp) as start_time,\n          MAX(timestamp) as end_time\n        FROM energy_data \n        WHERE device_id = ? AND timestamp >= datetime('now', ?)\n        GROUP BY data_type, unit\n        ORDER BY data_type\n      `;\n\n      const stats = await this.queryDatabase(sql, [deviceId, timeCondition]);\n\n      // 计算额外的统计指标\n      const enrichedStats = await Promise.all(\n        stats.map(async stat => {\n          const variance = await this.calculateVariance(deviceId, stat.data_type, timeRange);\n          const trend = await this.calculateTrend(deviceId, stat.data_type, timeRange);\n\n          return {\n            ...stat,\n            variance,\n            std_deviation: Math.sqrt(variance),\n            trend_direction: trend.direction,\n            trend_rate: trend.rate,\n            efficiency_score: this.calculateEfficiencyScore(stat)\n          };\n        })\n      );\n\n      this.setCache(cacheKey, enrichedStats);\n      return enrichedStats;\n    } catch (error) {\n      logger.error('获取设备能源统计失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 获取园区整体能源消耗趋势\n   */\n  async getParkEnergyTrend(parkId, timeRange = '7d', interval = 'hour') {\n    try {\n      const cacheKey = `park_trend_${parkId}_${timeRange}_${interval}`;\n      const cached = this.getFromCache(cacheKey);\n      if (cached) {return cached;}\n\n      const timeCondition = this.getTimeCondition(timeRange);\n      const groupBy = this.getGroupByInterval(interval);\n\n      const sql = `\n        SELECT \n          ${groupBy} as time_period,\n          ed.data_type,\n          SUM(ed.value) as total_consumption,\n          AVG(ed.value) as avg_consumption,\n          COUNT(DISTINCT ed.device_id) as active_devices,\n          ed.unit\n        FROM energy_data ed\n        JOIN devices d ON ed.device_id = d.id\n        JOIN buildings b ON d.building_id = b.id\n        WHERE b.park_id = ? AND ed.timestamp >= datetime('now', ?)\n        GROUP BY time_period, ed.data_type, ed.unit\n        ORDER BY time_period, ed.data_type\n      `;\n\n      const trendData = await this.queryDatabase(sql, [parkId, timeCondition]);\n\n      // 按数据类型分组\n      const groupedData = this.groupByDataType(trendData);\n\n      // 计算趋势指标\n      const trendsWithMetrics = {};\n      for (const [dataType, data] of Object.entries(groupedData)) {\n        trendsWithMetrics[dataType] = {\n          data,\n          metrics: this.calculateTrendMetrics(data)\n        };\n      }\n\n      this.setCache(cacheKey, trendsWithMetrics);\n      return trendsWithMetrics;\n    } catch (error) {\n      logger.error('获取园区能源趋势失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 生成能源消耗报告\n   */\n  async generateEnergyReport(params) {\n    try {\n      const {\n        scope, // 'device', 'building', 'park'\n        scopeId,\n        timeRange = '30d',\n        includeComparison = true,\n        includeForecasting = false\n      } = params;\n\n      const report = {\n        id: uuidv4(),\n        scope,\n        scope_id: scopeId,\n        time_range: timeRange,\n        generated_at: new Date().toISOString(),\n        summary: {},\n        details: {},\n        recommendations: []\n      };\n\n      // 获取基础统计数据\n      switch (scope) {\n        case 'device':\n          report.summary = await this.getDeviceEnergyStats(scopeId, timeRange);\n          break;\n        case 'building':\n          report.summary = await this.getBuildingEnergyStats(scopeId, timeRange);\n          break;\n        case 'park':\n          report.summary = await this.getParkEnergyStats(scopeId, timeRange);\n          break;\n      }\n\n      // 添加对比分析\n      if (includeComparison) {\n        report.comparison = await this.getComparisonData(scope, scopeId, timeRange);\n      }\n\n      // 添加预测分析\n      if (includeForecasting) {\n        report.forecast = await this.generateForecast(scope, scopeId);\n      }\n\n      // 生成建议\n      report.recommendations = await this.generateRecommendations(report.summary);\n\n      // 保存报告\n      await this.saveReport(report);\n\n      return report;\n    } catch (error) {\n      logger.error('生成能源报告失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 计算能源效率评分\n   */\n  async calculateEnergyEfficiency(scopeId, scope = 'building') {\n    try {\n      const baselineData = await this.getBaselineConsumption(scopeId, scope);\n      const currentData = await this.getCurrentConsumption(scopeId, scope);\n\n      if (!baselineData || !currentData) {\n        return { score: null, message: '数据不足，无法计算效率评分' };\n      }\n\n      // 计算效率评分 (0-100)\n      const efficiency = (baselineData.total - currentData.total) / baselineData.total;\n      const score = Math.max(MATH_CONSTANTS.ZERO, Math.min(MATH_CONSTANTS.ONE_HUNDRED, MATH_CONSTANTS.FIFTY + efficiency * MATH_CONSTANTS.FIFTY));\n\n      const result = {\n        score: Math.round(score),\n        baseline_consumption: baselineData.total,\n        current_consumption: currentData.total,\n        improvement: efficiency,\n        rating: this.getEfficiencyRating(score)\n      };\n\n      return result;\n    } catch (error) {\n      logger.error('计算能源效率失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 检测能源消耗异常\n   */\n  async detectEnergyAnomalies(deviceId, timeRange = '7d') {\n    try {\n      const sql = `\n        SELECT \n          id,\n          device_id,\n          data_type,\n          value,\n          unit,\n          timestamp,\n          is_anomaly,\n          anomaly_reason\n        FROM energy_data \n        WHERE device_id = ? \n          AND timestamp >= datetime('now', ?)\n          AND (is_anomaly = 1 OR value > (\n            SELECT AVG(value) + 3 * (\n              SELECT SQRT(AVG((value - sub.avg_val) * (value - sub.avg_val)))\n              FROM (\n                SELECT AVG(value) as avg_val \n                FROM energy_data \n                WHERE device_id = ? AND data_type = energy_data.data_type\n              ) sub\n            )\n            FROM energy_data \n            WHERE device_id = ? AND data_type = energy_data.data_type\n          ))\n        ORDER BY timestamp DESC\n      `;\n\n      const timeCondition = this.getTimeCondition(timeRange);\n      const anomalies = await this.queryDatabase(sql, [\n        deviceId,\n        timeCondition,\n        deviceId,\n        deviceId\n      ]);\n\n      // 分析异常模式\n      const patterns = this.analyzeAnomalyPatterns(anomalies);\n\n      return {\n        anomalies,\n        patterns,\n        summary: {\n          total_anomalies: anomalies.length,\n          anomaly_rate: anomalies.length / (await this.getTotalDataPoints(deviceId, timeRange)),\n          most_common_type: patterns.mostCommonType,\n          severity_distribution: patterns.severityDistribution\n        }\n      };\n    } catch (error) {\n      logger.error('检测能源异常失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 获取能源成本分析\n   */\n  async getEnergyCostAnalysis(scopeId, scope = 'building', timeRange = '30d') {\n    try {\n      // 获取能源消耗数据\n      const consumptionData = await this.getEnergyConsumption(scopeId, scope, timeRange);\n\n      // 获取能源价格配置\n      const energyPrices = await this.getEnergyPrices();\n\n      // 计算成本\n      const costAnalysis = {\n        total_cost: 0,\n        cost_breakdown: {},\n        cost_trends: [],\n        savings_opportunities: []\n      };\n\n      for (const [energyType, consumption] of Object.entries(consumptionData)) {\n        const price = energyPrices[energyType] || 0;\n        const cost = consumption.total * price;\n\n        costAnalysis.total_cost += cost;\n        costAnalysis.cost_breakdown[energyType] = {\n          consumption: consumption.total,\n          unit_price: price,\n          total_cost: cost,\n          percentage: 0 // 将在后面计算\n        };\n      }\n\n      // 计算百分比\n      for (const energyType of Object.keys(costAnalysis.cost_breakdown)) {\n        costAnalysis.cost_breakdown[energyType].percentage =\n          (costAnalysis.cost_breakdown[energyType].total_cost / costAnalysis.total_cost) * MATH_CONSTANTS.ONE_HUNDRED;\n      }\n\n      // 识别节约机会\n      costAnalysis.savings_opportunities = await this.identifySavingsOpportunities(\n        consumptionData,\n        energyPrices\n      );\n\n      return costAnalysis;\n    } catch (error) {\n      logger.error('获取能源成本分析失败:', error);\n      throw error;\n    }\n  }\n\n  // ==================== 辅助方法 ====================\n\n  /**\n   * 获取时间条件\n   */\n  getTimeCondition(timeRange) {\n    const conditions = {\n      '1h': TIME_CONDITIONS.ONE_HOUR,\n      '6h': TIME_CONDITIONS.SIX_HOURS,\n      '24h': TIME_CONDITIONS.ONE_DAY,\n      '7d': TIME_CONDITIONS.SEVEN_DAYS,\n      '30d': TIME_CONDITIONS.THIRTY_DAYS,\n      '90d': TIME_CONDITIONS.NINETY_DAYS,\n      '1y': TIME_CONDITIONS.ONE_YEAR\n    };\n    return conditions[timeRange] || TIME_CONDITIONS.ONE_DAY;\n  }\n\n  /**\n   * 获取分组间隔\n   */\n  getGroupByInterval(interval) {\n    const intervals = {\n      minute: \"strftime('%Y-%m-%d %H:%M', timestamp)\",\n      hour: \"strftime('%Y-%m-%d %H:00', timestamp)\",\n      day: \"strftime('%Y-%m-%d', timestamp)\",\n      week: \"strftime('%Y-W%W', timestamp)\",\n      month: \"strftime('%Y-%m', timestamp)\"\n    };\n    return intervals[interval] || intervals.hour;\n  }\n\n  /**\n   * 按数据类型分组\n   */\n  groupByDataType(data) {\n    return data.reduce((groups, item) => {\n      const key = `${item.data_type}_${item.unit}`;\n      if (!groups[key]) {\n        groups[key] = [];\n      }\n      groups[key].push(item);\n      return groups;\n    }, {});\n  }\n\n  /**\n   * 计算趋势指标\n   */\n\n  // TODO: 考虑将此函数拆分为更小的函数 (当前 22 行)\n\n  // TODO: 考虑将此函数拆分为更小的函数 (当前 22 行)\n\n  // TODO: 考虑将此函数拆分为更小的函数 (当前 22 行)\n\n  // TODO: 考虑将此函数拆分为更小的函数 (当前 22 行)\n\n  calculateTrendMetrics(data) {\n    if (!(data.length < 2)) {\n      return { direction: 'stable', rate: 0, correlation: 0 };\n    }\n\n    const values = data.map(d => d.total_consumption);\n    const n = values.length;\n\n    // 计算线性回归斜率\n    const sumX = (n * (n - MATH_CONSTANTS.ONE)) / MATH_CONSTANTS.TWO;\n    const sumY = values.reduce((sum, val) => sum + val, 0);\n    const sumXY = values.reduce((sum, val, idx) => sum + val * idx, 0);\n    const sumX2 = (n * (n - MATH_CONSTANTS.ONE) * (MATH_CONSTANTS.TWO * n - MATH_CONSTANTS.ONE)) / MATH_CONSTANTS.SIX;\n\n    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n\n    return {\n      direction: slope > MATH_CONSTANTS.TEN_PERCENT ? 'increasing' : slope < -MATH_CONSTANTS.TEN_PERCENT ? 'decreasing' : 'stable',\n      rate: Math.abs(slope),\n      correlation: this.calculateCorrelation(values)\n    };\n  }\n\n  /**\n   * 计算相关系数\n   */\n  calculateCorrelation(values) {\n    const n = values.length;\n    const indices = Array.from({ length: n }, (_, i) => i);\n\n    const meanX = (n - MATH_CONSTANTS.ONE) / MATH_CONSTANTS.TWO;\n    const meanY = values.reduce((sum, val) => sum + val, 0) / n;\n\n    const numerator = indices.reduce((sum, x, i) => sum + (x - meanX) * (values[i] - meanY), 0);\n\n    const denomX = Math.sqrt(indices.reduce((sum, x) => sum + Math.pow(x - meanX, 2), 0));\n    const denomY = Math.sqrt(values.reduce((sum, y) => sum + Math.pow(y - meanY, 2), 0));\n\n    return denomX * denomY === MATH_CONSTANTS.ZERO ? MATH_CONSTANTS.ZERO : numerator / (denomX * denomY);\n  }\n\n  /**\n   * 计算方差\n   */\n  async calculateVariance(deviceId, dataType, timeRange) {\n    const sql = `\n      SELECT AVG(value) as mean, COUNT(*) as count\n      FROM energy_data \n      WHERE device_id = ? AND data_type = ? AND timestamp >= datetime('now', ?)\n    `;\n\n    const timeCondition = this.getTimeCondition(timeRange);\n    const result = await this.queryDatabase(sql, [deviceId, dataType, timeCondition]);\n\n    const [firstResult] = result;\n    if (!firstResult || firstResult.count === 0) {return 0;}\n\n    const { mean } = firstResult;\n\n    const varianceSql = `\n      SELECT AVG((value - ?) * (value - ?)) as variance\n      FROM energy_data \n      WHERE device_id = ? AND data_type = ? AND timestamp >= datetime('now', ?)\n    `;\n\n    const varianceResult = await this.queryDatabase(varianceSql, [\n      mean,\n      mean,\n      deviceId,\n      dataType,\n      timeCondition\n    ]);\n    return varianceResult[0]?.variance || 0;\n  }\n\n  /**\n   * 计算趋势\n   */\n  async calculateTrend(deviceId, dataType, timeRange) {\n    const sql = `\n      SELECT value, timestamp\n      FROM energy_data \n      WHERE device_id = ? AND data_type = ? AND timestamp >= datetime('now', ?)\n      ORDER BY timestamp\n    `;\n\n    const timeCondition = this.getTimeCondition(timeRange);\n    const data = await this.queryDatabase(sql, [deviceId, dataType, timeCondition]);\n\n    if (data.length < 2) {\n      return { direction: 'stable', rate: 0 };\n    }\n\n    const [firstItem] = data;\n    const lastItem = data[data.length - 1];\n    const firstValue = firstItem.value;\n    const lastValue = lastItem.value;\n    const change = (lastValue - firstValue) / firstValue;\n\n    return {\n      direction: change > ANOMALY_THRESHOLDS.CHANGE_THRESHOLD ? 'increasing' : change < -ANOMALY_THRESHOLDS.CHANGE_THRESHOLD ? 'decreasing' : 'stable',\n      rate: Math.abs(change)\n    };\n  }\n\n  /**\n   * 计算效率评分\n   */\n  calculateEfficiencyScore(stat) {\n    // 基于数据质量、变异系数等计算效率评分\n    const cv = stat.avg_value > 0 ? Math.sqrt(stat.variance || 0) / stat.avg_value : 0;\n    const score = Math.max(MATH_CONSTANTS.ZERO, Math.min(MATH_CONSTANTS.ONE_HUNDRED, MATH_CONSTANTS.ONE_HUNDRED - cv * MATH_CONSTANTS.ONE_HUNDRED));\n    return Math.round(score);\n  }\n\n  /**\n   * 获取效率等级\n   */\n  getEfficiencyRating(score) {\n    if (score >= EFFICIENCY_THRESHOLDS.EXCELLENT) {return 'A+';}\n    if (score >= EFFICIENCY_THRESHOLDS.GOOD) {return 'A';}\n    if (score >= EFFICIENCY_THRESHOLDS.AVERAGE) {return 'B';}\n    if (score >= EFFICIENCY_THRESHOLDS.POOR) {return 'C';}\n    if (score >= EFFICIENCY_THRESHOLDS.VERY_POOR) {return 'D';}\n    return 'F';\n  }\n\n  /**\n   * 缓存管理\n   */\n  getFromCache(key) {\n    const cached = this.cache.get(key);\n    // TODO: 考虑使用早期返回或策略模式来减少嵌套\n    // TODO: 考虑使用早期返回或策略模式来减少嵌套\n    // TODO: 考虑使用早期返回或策略模式来减少嵌套\n    // TODO: 考虑使用早期返回或策略模式来减少嵌套\n    // TODO: 考虑使用早期返回或策略模式来减少嵌套\n    // TODO: 考虑使用早期返回或策略模式来减少嵌套\n    // TODO: 考虑使用早期返回或策略模式来减少嵌套\n    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {\n      return cached.data;\n    }\n    return null;\n  }\n\n  setCache(key, data) {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now()\n    });\n  }\n\n  /**\n   * 数据库查询封装\n   */\n  queryDatabase(sql, params = []) {\n    return new Promise((resolve, reject) => {\n      dbPromise\n        .then(db => {\n          db.raw(sql, params).then(rows => {\n            resolve(rows || []);\n          }).catch(err => {\n            reject(err);\n          });\n        })\n        .catch(reject);\n    });\n  }\n\n  /**\n   * 获取建筑能源统计\n   */\n  async getBuildingEnergyStats(buildingId, timeRange = '24h') {\n    try {\n      const cacheKey = `building_stats_${buildingId}_${timeRange}`;\n      const cached = this.getFromCache(cacheKey);\n      if (cached) {return cached;}\n\n      const timeCondition = this.getTimeCondition(timeRange);\n\n      const sql = `\n        SELECT \n          ed.data_type,\n          COUNT(*) as data_points,\n          AVG(ed.value) as avg_value,\n          MIN(ed.value) as min_value,\n          MAX(ed.value) as max_value,\n          SUM(ed.value) as total_value,\n          ed.unit,\n          COUNT(DISTINCT ed.device_id) as device_count\n        FROM energy_data ed\n        JOIN devices d ON ed.device_id = d.id\n        WHERE d.building_id = ? AND ed.timestamp >= datetime('now', ?)\n        GROUP BY ed.data_type, ed.unit\n        ORDER BY ed.data_type\n      `;\n\n      const stats = await this.queryDatabase(sql, [buildingId, timeCondition]);\n      this.setCache(cacheKey, stats);\n      return stats;\n    } catch (error) {\n      logger.error('获取建筑能源统计失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 获取园区能源统计\n   */\n  async getParkEnergyStats(parkId, timeRange = '24h') {\n    try {\n      const cacheKey = `park_stats_${parkId}_${timeRange}`;\n      const cached = this.getFromCache(cacheKey);\n      if (cached) {return cached;}\n\n      const timeCondition = this.getTimeCondition(timeRange);\n\n      const sql = `\n        SELECT \n          ed.data_type,\n          COUNT(*) as data_points,\n          AVG(ed.value) as avg_value,\n          MIN(ed.value) as min_value,\n          MAX(ed.value) as max_value,\n          SUM(ed.value) as total_value,\n          ed.unit,\n          COUNT(DISTINCT ed.device_id) as device_count,\n          COUNT(DISTINCT d.building_id) as building_count\n        FROM energy_data ed\n        JOIN devices d ON ed.device_id = d.id\n        JOIN buildings b ON d.building_id = b.id\n        WHERE b.park_id = ? AND ed.timestamp >= datetime('now', ?)\n        GROUP BY ed.data_type, ed.unit\n        ORDER BY ed.data_type\n      `;\n\n      const stats = await this.queryDatabase(sql, [parkId, timeCondition]);\n      this.setCache(cacheKey, stats);\n      return stats;\n    } catch (error) {\n      logger.error('获取园区能源统计失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 获取对比数据\n   */\n  async getComparisonData(scope, scopeId, timeRange) {\n    try {\n      // 获取当前周期数据\n      const currentData = await this.getEnergyConsumption(scopeId, scope, timeRange);\n\n      // 获取上一个周期数据\n      const previousTimeRange = this.getPreviousTimeRange(timeRange);\n      const previousData = await this.getEnergyConsumption(\n        scopeId,\n        scope,\n        timeRange,\n        previousTimeRange\n      );\n\n      // 计算对比指标\n      const comparison = {};\n      for (const [energyType, current] of Object.entries(currentData)) {\n        const previous = previousData[energyType];\n        if (previous) {\n          const change = (current.total - previous.total) / previous.total;\n          comparison[energyType] = {\n            current: current.total,\n            previous: previous.total,\n            change,\n            change_percentage: change * 100,\n            trend: change > ANOMALY_THRESHOLDS.CHANGE_THRESHOLD ? 'increasing' : change < -ANOMALY_THRESHOLDS.CHANGE_THRESHOLD ? 'decreasing' : 'stable'\n          };\n        } else {\n          comparison[energyType] = {\n            current: current.total,\n            previous: 0,\n            change: null,\n            change_percentage: null,\n            trend: 'new'\n          };\n        }\n      }\n\n      return comparison;\n    } catch (error) {\n      logger.error('获取对比数据失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 生成预测\n   */\n  async generateForecast(scope, scopeId) {\n    try {\n      // 获取历史数据用于预测\n      const historicalData = await this.getHistoricalData(scopeId, scope, '90d');\n\n      const forecast = {};\n      for (const [energyType, data] of Object.entries(historicalData)) {\n        if (data.length < MATH_CONSTANTS.SEVEN) {\n          forecast[energyType] = {\n            message: '数据不足，无法生成预测',\n            confidence: 0\n          };\n          continue;\n        }\n\n        // 简单的线性回归预测\n        const trend = this.calculateLinearTrend(data);\n        const nextPeriodForecast = this.extrapolateTrend(trend, MATH_CONSTANTS.SEVEN); // 预测未来7天\n\n        forecast[energyType] = {\n          trend_direction: trend.direction,\n          predicted_values: nextPeriodForecast,\n          confidence: this.calculateForecastConfidence(data, trend),\n          method: 'linear_regression'\n        };\n      }\n\n      return forecast;\n    } catch (error) {\n      logger.error('生成预测失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 生成建议\n   */\n  async generateRecommendations(summary) {\n    const recommendations = [];\n\n    try {\n      for (const stat of summary) {\n        // 基于效率评分生成建议\n        if (stat.efficiency_score < EFFICIENCY_THRESHOLDS.POOR) {\n          recommendations.push({\n            type: 'efficiency',\n            priority: 'high',\n            title: `${stat.data_type}能源效率偏低`,\n            description: `当前效率评分为${stat.efficiency_score}分，建议检查设备运行状态和优化配置`,\n            potential_savings: this.estimatePotentialSavings(stat)\n          });\n        }\n\n        // 基于趋势生成建议\n        if (stat.trend_direction === 'increasing' && stat.trend_rate > MATH_CONSTANTS.TWENTY_PERCENT) {\n          recommendations.push({\n            type: 'trend',\n            priority: 'medium',\n            title: `${stat.data_type}消耗呈上升趋势`,\n            description: `消耗量增长率为${(stat.trend_rate * 100).toFixed(1)}%，建议关注使用模式变化`,\n            potential_savings: null\n          });\n        }\n\n        // 基于变异系数生成建议\n        if (stat.std_deviation / stat.avg_value > MATH_CONSTANTS.FIFTY_PERCENT) {\n          recommendations.push({\n            type: 'stability',\n            priority: 'low',\n            title: `${stat.data_type}消耗波动较大`,\n            description: '能源消耗不稳定，建议检查设备运行规律和负载管理',\n            potential_savings: null\n          });\n        }\n      }\n\n      return recommendations;\n    } catch (error) {\n      logger.error('生成建议失败:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 获取能源消耗数据\n   */\n  async getEnergyConsumption(scopeId, scope, timeRange, customTimeRange = null) {\n    try {\n\n  // TODO: 考虑将此函数拆分为更小的函数 (当前 37 行)\n\n  // TODO: 考虑将此函数拆分为更小的函数 (当前 37 行)\n\n  // TODO: 考虑将此函数拆分为更小的函数 (当前 37 行)\n\n  // TODO: 考虑将此函数拆分为更小的函数 (当前 37 行)\n\n      const timeCondition = customTimeRange || this.getTimeCondition(timeRange);\n      let sql; let params;\n\n      switch (scope) {\n        case 'device':\n          sql = `\n            SELECT data_type, SUM(value) as total, unit\n            FROM energy_data \n            WHERE device_id = ? AND timestamp >= datetime('now', ?)\n            GROUP BY data_type, unit\n          `;\n          params = [scopeId, timeCondition];\n          break;\n\n        case 'building':\n          sql = `\n            SELECT ed.data_type, SUM(ed.value) as total, ed.unit\n            FROM energy_data ed\n            JOIN devices d ON ed.device_id = d.id\n            WHERE d.building_id = ? AND ed.timestamp >= datetime('now', ?)\n            GROUP BY ed.data_type, ed.unit\n          `;\n          params = [scopeId, timeCondition];\n          break;\n\n        case 'park':\n          sql = `\n            SELECT ed.data_type, SUM(ed.value) as total, ed.unit\n            FROM energy_data ed\n            JOIN devices d ON ed.device_id = d.id\n            JOIN buildings b ON d.building_id = b.id\n            WHERE b.park_id = ? AND ed.timestamp >= datetime('now', ?)\n            GROUP BY ed.data_type, ed.unit\n          `;\n          params = [scopeId, timeCondition];\n          break;\n\n        default:\n          throw new Error('无效的scope参数');\n      }\n\n      const data = await this.queryDatabase(sql, params);\n\n      // 转换为对象格式\n      const consumption = {};\n      data.forEach(item => {\n        const key = `${item.data_type}_${item.unit}`;\n        consumption[key] = {\n          total: item.total,\n          unit: item.unit\n        };\n      });\n\n      return consumption;\n    } catch (error) {\n      logger.error('获取能源消耗数据失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 获取能源价格\n   */\n  async getEnergyPrices() {\n    try {\n      const sql = `\n        SELECT energy_type, price, unit\n        FROM energy_prices \n        WHERE is_active = 1\n        ORDER BY effective_date DESC\n      `;\n\n      const prices = await this.queryDatabase(sql);\n\n      // 转换为对象格式\n      const priceMap = {};\n      prices.forEach(price => {\n        priceMap[`${price.energy_type}_${price.unit}`] = price.price;\n      });\n\n      // 如果没有配置价格，使用默认值\n      if (!(Object.keys(priceMap).length === 0)) {\n        return {\n          electricity_kWh: 0.8,\n          water_m3: 3.5,\n          gas_m3: 2.8\n        };\n      }\n\n      return priceMap;\n    } catch (error) {\n      logger.error('获取能源价格失败:', error);\n      return {};\n    }\n  }\n\n  /**\n   * 识别节约机会\n   */\n  async identifySavingsOpportunities(consumptionData, energyPrices) {\n    const opportunities = [];\n\n    try {\n      for (const [energyType, consumption] of Object.entries(consumptionData)) {\n        const price = energyPrices[energyType] || 0;\n        const _currentCost = consumption.total * price;\n\n        // 基于行业基准识别节约机会\n        const benchmark = await this.getIndustryBenchmark(energyType);\n        if (benchmark && consumption.total > benchmark.average * MATH_CONSTANTS.ONE_POINT_TWO) {\n          const potentialSaving = (consumption.total - benchmark.average) * price;\n          opportunities.push({\n            energy_type: energyType,\n            current_consumption: consumption.total,\n            benchmark_average: benchmark.average,\n            excess_consumption: consumption.total - benchmark.average,\n            potential_cost_saving: potentialSaving,\n            recommendation: `${energyType}消耗超出行业平均水平20%，建议优化使用策略`\n          });\n        }\n      }\n\n      return opportunities;\n    } catch (error) {\n      logger.error('识别节约机会失败:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 获取基准消耗\n   */\n  async getBaselineConsumption(scopeId, scope) {\n    try {\n      const sql = `\n        SELECT SUM(baseline_value) as total\n        FROM baseline_consumption \n        WHERE scope = ? AND scope_id = ?\n      `;\n\n      const result = await this.queryDatabase(sql, [scope, scopeId]);\n      return result[0] || null;\n    } catch (error) {\n      logger.error('获取基准消耗失败:', error);\n      return null;\n    }\n  }\n\n  /**\n   * 获取当前消耗\n   */\n  async getCurrentConsumption(scopeId, scope) {\n    try {\n      const consumption = await this.getEnergyConsumption(scopeId, scope, '30d');\n      const total = Object.values(consumption).reduce((sum, item) => sum + item.total, 0);\n      return { total };\n    } catch (error) {\n      logger.error('获取当前消耗失败:', error);\n      return null;\n    }\n  }\n\n  /**\n   * 获取行业基准\n   */\n  async getIndustryBenchmark(energyType) {\n    // 这里可以从外部数据源获取行业基准数据\n    // 暂时返回模拟数据\n    const benchmarks = {\n      electricity_kWh: { average: 1000, unit: 'kWh' },\n      water_m3: { average: 50, unit: 'm3' },\n      gas_m3: { average: 100, unit: 'm3' }\n    };\n\n    return benchmarks[energyType] || null;\n  }\n\n  /**\n   * 获取历史数据\n   */\n  async getHistoricalData(scopeId, scope, timeRange) {\n    try {\n      const _consumption = await this.getEnergyConsumption(scopeId, scope, timeRange);\n\n      // 按天分组获取详细历史数据\n      const timeCondition = this.getTimeCondition(timeRange);\n      let sql; let params;\n\n      switch (scope) {\n        case 'device':\n          sql = `\n            SELECT \n              strftime('%Y-%m-%d', timestamp) as date,\n              data_type,\n              SUM(value) as daily_total\n            FROM energy_data \n            WHERE device_id = ? AND timestamp >= datetime('now', ?)\n            GROUP BY date, data_type\n            ORDER BY date\n          `;\n          params = [scopeId, timeCondition];\n          break;\n\n        default:\n          // 其他scope的实现类似\n          return {};\n      }\n\n      const data = await this.queryDatabase(sql, params);\n\n      // 按数据类型分组\n      const grouped = {};\n      data.forEach(item => {\n        if (!grouped[item.data_type]) {\n          grouped[item.data_type] = [];\n        }\n        grouped[item.data_type].push({\n          date: item.date,\n          value: item.daily_total\n        });\n      });\n\n      return grouped;\n    } catch (error) {\n      logger.error('获取历史数据失败:', error);\n      return {};\n    }\n  }\n\n  /**\n   * 计算线性趋势\n   */\n  calculateLinearTrend(data) {\n    if (data.length < 2) {\n      return { direction: 'stable', slope: 0, intercept: 0 };\n    }\n\n    const n = data.length;\n    const sumX = (n * (n - MATH_CONSTANTS.ONE)) / MATH_CONSTANTS.TWO;\n    const sumY = data.reduce((sum, item) => sum + item.value, MATH_CONSTANTS.ZERO);\n    const sumXY = data.reduce((sum, item, index) => sum + item.value * index, MATH_CONSTANTS.ZERO);\n    const sumX2 = (n * (n - MATH_CONSTANTS.ONE) * (MATH_CONSTANTS.TWO * n - MATH_CONSTANTS.ONE)) / MATH_CONSTANTS.SIX;\n\n    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n    const intercept = (sumY - slope * sumX) / n;\n\n    return {\n      direction: slope > MATH_CONSTANTS.TEN_PERCENT ? 'increasing' : slope < -MATH_CONSTANTS.TEN_PERCENT ? 'decreasing' : 'stable',\n      slope,\n      intercept\n    };\n  }\n\n  /**\n   * 外推趋势\n   */\n  extrapolateTrend(trend, periods) {\n    const predictions = [];\n    const lastIndex = periods;\n\n    for (let i = 1; i <= periods; i++) {\n      const predictedValue = trend.intercept + trend.slope * (lastIndex + i);\n      predictions.push(Math.max(MATH_CONSTANTS.ZERO, predictedValue)); // 确保预测值不为负\n    }\n\n    return predictions;\n  }\n\n  /**\n   * 计算预测置信度\n   */\n  calculateForecastConfidence(data, trend) {\n    if (data.length < MATH_CONSTANTS.THREE) {return MATH_CONSTANTS.ZERO;}\n\n    // 计算R²值作为置信度指标\n    const actualValues = data.map(item => item.value);\n    const predictedValues = data.map((item, index) => trend.intercept + trend.slope * index);\n\n    const meanActual = actualValues.reduce((sum, val) => sum + val, MATH_CONSTANTS.ZERO) / actualValues.length;\n\n    const totalSumSquares = actualValues.reduce(\n      (sum, val) => sum + Math.pow(val - meanActual, MATH_CONSTANTS.TWO),\n      MATH_CONSTANTS.ZERO\n    );\n    const residualSumSquares = actualValues.reduce((sum, val, index) => sum + Math.pow(val - predictedValues[index], MATH_CONSTANTS.TWO), MATH_CONSTANTS.ZERO);\n\n    const rSquared = MATH_CONSTANTS.ONE - residualSumSquares / totalSumSquares;\n    return Math.max(MATH_CONSTANTS.ZERO, Math.min(MATH_CONSTANTS.ONE, rSquared)) * MATH_CONSTANTS.ONE_HUNDRED; // 转换为百分比\n  }\n\n  /**\n   * 获取上一个时间范围\n   */\n  getPreviousTimeRange(timeRange) {\n    const ranges = {\n      '1h': PREVIOUS_TIME_RANGES.ONE_HOUR,\n      '6h': PREVIOUS_TIME_RANGES.SIX_HOURS,\n      '24h': PREVIOUS_TIME_RANGES.ONE_DAY,\n      '7d': PREVIOUS_TIME_RANGES.SEVEN_DAYS,\n      '30d': PREVIOUS_TIME_RANGES.THIRTY_DAYS,\n      '90d': PREVIOUS_TIME_RANGES.NINETY_DAYS,\n      '1y': PREVIOUS_TIME_RANGES.ONE_YEAR\n    };\n    return ranges[timeRange] || PREVIOUS_TIME_RANGES.ONE_DAY;\n  }\n\n  /**\n   * 估算潜在节约\n   */\n  estimatePotentialSavings(stat) {\n    // 基于效率评分估算潜在节约百分比\n    const efficiencyGap = (EFFICIENCY_THRESHOLDS.GOOD - stat.efficiency_score) / MATH_CONSTANTS.ONE_HUNDRED; // 假设80分为良好水平\n    const potentialSavingPercentage = Math.max(MATH_CONSTANTS.ZERO, efficiencyGap * MATH_CONSTANTS.THIRTY_PERCENT); // 最多30%的节约潜力\n\n    return {\n      percentage: potentialSavingPercentage * MATH_CONSTANTS.ONE_HUNDRED,\n      estimated_amount: stat.total_value * potentialSavingPercentage\n    };\n  }\n\n  /**\n   * 分析异常模式\n   */\n  analyzeAnomalyPatterns(anomalies) {\n    const patterns = {\n      mostCommonType: null,\n      severityDistribution: {},\n      timePatterns: {},\n      devicePatterns: {}\n    };\n\n    if (anomalies.length === 0) {return patterns;}\n\n    // 分析最常见的异常类型\n    const typeCount = {};\n    anomalies.forEach(anomaly => {\n      const reason = anomaly.anomaly_reason || 'unknown';\n      typeCount[reason] = (typeCount[reason] || 0) + 1;\n    });\n\n    patterns.mostCommonType = Object.keys(typeCount).reduce((a, b) =>\n      (typeCount[a] > typeCount[b] ? a : b)\n    );\n\n    // 分析严重程度分布\n    anomalies.forEach(anomaly => {\n      const severity = this.classifyAnomalySeverity(anomaly.value);\n      patterns.severityDistribution[severity] = (patterns.severityDistribution[severity] || 0) + 1;\n    });\n\n    return patterns;\n  }\n\n  /**\n   * 分类异常严重程度\n   */\n  classifyAnomalySeverity(value) {\n    // 简单的严重程度分类逻辑\n    if (value > MATH_CONSTANTS.ONE_THOUSAND) {return 'high';}\n    if (value > MATH_CONSTANTS.FIVE_HUNDRED) {return 'medium';}\n    return 'low';\n  }\n\n  /**\n   * 获取总数据点数\n   */\n  async getTotalDataPoints(deviceId, timeRange) {\n    try {\n      const timeCondition = this.getTimeCondition(timeRange);\n      const sql = `\n        SELECT COUNT(*) as total\n        FROM energy_data \n        WHERE device_id = ? AND timestamp >= datetime('now', ?)\n      `;\n\n      const result = await this.queryDatabase(sql, [deviceId, timeCondition]);\n      return result[0]?.total || MATH_CONSTANTS.ZERO;\n    } catch (error) {\n      logger.error('获取总数据点数失败:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * 保存报告\n   */\n  async saveReport(report) {\n    const _sql = `\n      INSERT INTO energy_reports (\n        id, scope, scope_id, time_range, report_data, generated_at\n      ) VALUES (?, ?, ?, ?, ?, ?)\n    `;\n\n    // 模拟数据库保存操作\n    return new Promise((resolve) => {\n      logger.info('模拟保存报告:', report.id);\n      resolve(report.id);\n    });\n  }\n}\n\nexport default EnergyAnalytics;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]