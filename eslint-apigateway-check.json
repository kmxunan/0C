[{"filePath":"/Users/xunan/Documents/WebStormProjects/0C/src/core/architecture/ApiGateway.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'status' is defined but never used. Allowed unused args must match /^_/u.","line":449,"column":42,"nodeType":"Identifier","messageId":"unusedVar","endLine":449,"endColumn":48},{"ruleId":"no-undef","severity":2,"message":"'response' is not defined.","line":454,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":454,"endColumn":21}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * API网关\n * 零碳园区数字孪生系统的统一API入口\n * 提供路由、认证、限流、监控等功能\n */\n\nimport { EventEmitter } from 'events';\nimport logger from '../../shared/utils/logger.js';\nimport ServiceRegistry from './ServiceRegistry.js';\nimport { MATH_CONSTANTS } from '../../shared/constants/MathConstants.js';\nimport { HTTP_STATUS_CODES } from '../../shared/constants/HttpStatusCodes.js';\n\nclass ApiGateway extends EventEmitter {\n    constructor() {\n        super();\n        this.serviceRegistry = new ServiceRegistry();\n        this.routes = new Map();\n        this.middlewares = [];\n        this.rateLimiters = new Map();\n        this.authTokens = new Map();\n        this.requestStats = new Map();\n        \n        // 路由配置\n        this.routeConfig = {\n            '/api/v1/carbon': {\n                service: 'carbon-accounting-engine',\n                methods: ['GET', 'POST'],\n                auth: true,\n                rateLimit: { requests: 100, window: 60000 } // 100请求/分钟\n            },\n            '/api/v1/energy-flow': {\n                service: 'energy-flow-visualization',\n                methods: ['GET', 'POST'],\n                auth: true,\n                rateLimit: { requests: 50, window: 60000 }\n            },\n            '/api/v1/indicators': {\n                service: 'national-indicator-dashboard',\n                methods: ['GET', 'POST'],\n                auth: true,\n                rateLimit: { requests: 200, window: 60000 }\n            },\n            '/api/v1/green-electricity': {\n                service: 'green-electricity-tracing',\n                methods: ['GET', 'POST'],\n                auth: true,\n                rateLimit: { requests: 80, window: 60000 }\n            },\n            '/api/v1/reports': {\n                service: 'report-generator',\n                methods: ['GET', 'POST'],\n                auth: true,\n                rateLimit: { requests: 20, window: 60000 }\n            },\n            '/api/v1/integration': {\n                service: 'energy-carbon-integration',\n                methods: ['GET', 'POST'],\n                auth: true,\n                rateLimit: { requests: 150, window: 60000 }\n            }\n        };\n        \n        this.init();\n    }\n    \n    /**\n     * 初始化API网关\n     */\n    async init() {\n        try {\n            logger.info('🚀 API网关启动中...');\n            \n            // 等待服务注册中心初始化\n            await this.waitForServiceRegistry();\n            \n            // 初始化路由\n            this.initializeRoutes();\n            \n            // 初始化中间件\n            this.initializeMiddlewares();\n            \n            // 启动监控\n            this.startMonitoring();\n            \n            logger.info('✅ API网关启动完成');\n            this.emit('gateway:ready');\n        } catch (error) {\n            logger.error('API网关启动失败:', error);\n            throw error;\n        }\n    }\n    \n    /**\n     * 等待服务注册中心就绪\n     */\n    async waitForServiceRegistry() {\n        return new Promise((resolve) => {\n            if (this.serviceRegistry.services.size > 0) {\n                resolve();\n            } else {\n                this.serviceRegistry.on('service:registered', () => {\n                    resolve();\n                });\n            }\n        });\n    }\n    \n    /**\n     * 初始化路由\n     */\n    initializeRoutes() {\n        for (const [path, config] of Object.entries(this.routeConfig)) {\n            this.routes.set(path, {\n                ...config,\n                stats: {\n                    requests: 0,\n                    errors: 0,\n                    avgResponseTime: 0,\n                    lastAccess: null\n                }\n            });\n        }\n        \n        logger.info(`📋 已配置 ${this.routes.size} 个路由`);\n    }\n    \n    /**\n     * 初始化中间件\n     */\n    initializeMiddlewares() {\n        // 请求日志中间件\n        this.use(this.requestLoggerMiddleware.bind(this));\n        \n        // 认证中间件\n        this.use(this.authenticationMiddleware.bind(this));\n        \n        // 限流中间件\n        this.use(this.rateLimitMiddleware.bind(this));\n        \n        // CORS中间件\n        this.use(this.corsMiddleware.bind(this));\n        \n        // 错误处理中间件\n        this.use(this.errorHandlingMiddleware.bind(this));\n        \n        logger.info(`🔧 已加载 ${this.middlewares.length} 个中间件`);\n    }\n    \n    /**\n     * 添加中间件\n     */\n    use(middleware) {\n        this.middlewares.push(middleware);\n    }\n    \n    /**\n     * 处理HTTP请求\n     * @param {Object} request 请求对象\n     * @returns {Object} 响应对象\n     */\n    async handleRequest(request) {\n        const startTime = Date.now();\n        let response = {\n            status: 200,\n            headers: {},\n            body: null\n        };\n        \n        try {\n            // 创建请求上下文\n            const context = {\n                request,\n                response,\n                startTime,\n                route: null,\n                service: null,\n                user: null\n            };\n            \n            // 路由匹配\n            const route = this.matchRoute(request.path, request.method);\n            if (!route) {\n                return this.createErrorResponse(HTTP_STATUS_CODES.NOT_FOUND, '路由不存在');\n            }\n            \n            context.route = route;\n            \n            // 执行中间件链\n            for (const middleware of this.middlewares) {\n                const result = await middleware(context);\n                if (result && result.status) {\n                    return result; // 中间件返回响应，终止处理\n                }\n            }\n            \n            // 服务发现\n            const serviceInstance = this.serviceRegistry.discoverService(route.service);\n            if (!serviceInstance) {\n                return this.createErrorResponse(HTTP_STATUS_CODES.SERVICE_UNAVAILABLE, '服务不可用');\n            }\n            \n            context.service = serviceInstance;\n            \n            // 转发请求到后端服务\n            response = await this.forwardRequest(context);\n            \n            // 更新统计信息\n            this.updateRequestStats(route, startTime, response.status);\n            \n            return response;\n        } catch (error) {\n            logger.error('请求处理失败:', error);\n            return this.createErrorResponse(HTTP_STATUS_CODES.INTERNAL_SERVER_ERROR, '内部服务器错误', error.message);\n        }\n    }\n    \n    /**\n     * 路由匹配\n     */\n    matchRoute(path, method) {\n        for (const [routePath, routeConfig] of this.routes) {\n            if (this.pathMatches(path, routePath) && routeConfig.methods.includes(method)) {\n                return { path: routePath, ...routeConfig };\n            }\n        }\n        return null;\n    }\n    \n    /**\n     * 路径匹配\n     */\n    pathMatches(requestPath, routePath) {\n        // 简单的路径匹配，支持通配符\n        const routeRegex = routePath.replace(/\\*/g, '.*');\n        return new RegExp(`^${routeRegex}`).test(requestPath);\n    }\n    \n    /**\n     * 转发请求到后端服务\n     */\n    async forwardRequest(context) {\n        const { request, service } = context;\n        \n        try {\n            // 构建目标URL\n            const targetUrl = `http://${service.host}:${service.port}${request.path}`;\n            \n            // 模拟HTTP请求转发\n            const response = await this.makeHttpRequest({\n                url: targetUrl,\n                method: request.method,\n                headers: request.headers,\n                body: request.body\n            });\n            \n            return response;\n        } catch (error) {\n            logger.error(`请求转发失败 (${service.name}):`, error);\n            throw error;\n        }\n    }\n    \n    /**\n     * 模拟HTTP请求\n     */\n    async makeHttpRequest(options) {\n        // 模拟网络延迟\n        await new Promise(resolve => setTimeout(resolve, Math.random() * MATH_CONSTANTS.ONE_HUNDRED + MATH_CONSTANTS.FIFTY));\n        \n        // 模拟响应\n        return {\n            status: 200,\n            headers: {\n                'Content-Type': 'application/json',\n                'X-Service-Name': 'mock-service'\n            },\n            body: {\n                success: true,\n                data: {\n                    message: '模拟响应数据',\n                    timestamp: new Date().toISOString(),\n                    requestPath: options.url\n                }\n            }\n        };\n    }\n    \n    /**\n     * 请求日志中间件\n     */\n    async requestLoggerMiddleware(context) {\n        const { request } = context;\n        logger.info(`📥 ${request.method} ${request.path} - ${request.headers['user-agent'] || 'Unknown'}`);\n        \n        // 记录请求开始时间\n        context.requestStartTime = Date.now();\n    }\n    \n    /**\n     * 认证中间件\n     */\n    async authenticationMiddleware(context) {\n        const { request, route } = context;\n        \n        // 如果路由不需要认证，跳过\n        if (!route.auth) {\n            return;\n        }\n        \n        const authHeader = request.headers.authorization;\n        if (!authHeader || !authHeader.startsWith('Bearer ')) {\n            return this.createErrorResponse(HTTP_STATUS_CODES.UNAUTHORIZED, '缺少认证令牌');\n        }\n        \n        const token = authHeader.substring(MATH_CONSTANTS.SEVEN);\n        const user = this.validateToken(token);\n        \n        if (!user) {\n            return this.createErrorResponse(HTTP_STATUS_CODES.UNAUTHORIZED, '无效的认证令牌');\n        }\n        \n        context.user = user;\n        logger.debug(`🔐 用户认证成功: ${user.username}`);\n    }\n    \n    /**\n     * 限流中间件\n     */\n    async rateLimitMiddleware(context) {\n        const { request, route } = context;\n        \n        if (!route.rateLimit) {\n            return;\n        }\n        \n        const clientId = this.getClientId(request);\n        const rateLimitKey = `${route.path}:${clientId}`;\n        \n        if (this.isRateLimited(rateLimitKey, route.rateLimit)) {\n            return this.createErrorResponse(HTTP_STATUS_CODES.TOO_MANY_REQUESTS, '请求频率超限');\n        }\n        \n        this.recordRequest(rateLimitKey, route.rateLimit);\n    }\n    \n    /**\n     * CORS中间件\n     */\n    async corsMiddleware(context) {\n        const { response } = context;\n        \n        response.headers['Access-Control-Allow-Origin'] = '*';\n        response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS';\n        response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization';\n    }\n    \n    /**\n     * 错误处理中间件\n     */\n    async errorHandlingMiddleware(context) {\n        // 在请求完成后执行\n        const { response } = context;\n        \n        if (response.status >= HTTP_STATUS_CODES.BAD_REQUEST) {\n            logger.warn(`⚠️ 请求错误: ${response.status} - ${context.request.path}`);\n            this.emit('request:error', {\n                path: context.request.path,\n                status: response.status,\n                timestamp: new Date().toISOString()\n            });\n        }\n    }\n    \n    /**\n     * 验证令牌\n     */\n    validateToken(token) {\n        // 模拟令牌验证\n        const validTokens = {\n            'admin-token-123': { username: 'admin', role: 'administrator' },\n            'user-token-456': { username: 'user', role: 'operator' },\n            'readonly-token-789': { username: 'readonly', role: 'viewer' }\n        };\n        \n        return validTokens[token] || null;\n    }\n    \n    /**\n     * 获取客户端ID\n     */\n    getClientId(request) {\n        return request.headers['x-client-id'] || \n               request.headers['x-forwarded-for'] || \n               request.connection?.remoteAddress || \n               'unknown';\n    }\n    \n    /**\n     * 检查是否被限流\n     */\n    isRateLimited(key, rateLimit) {\n        const now = Date.now();\n        const windowStart = now - rateLimit.window;\n        \n        if (!this.rateLimiters.has(key)) {\n            this.rateLimiters.set(key, []);\n        }\n        \n        const requests = this.rateLimiters.get(key);\n        \n        // 清理过期的请求记录\n        const validRequests = requests.filter(timestamp => timestamp > windowStart);\n        this.rateLimiters.set(key, validRequests);\n        \n        return validRequests.length >= rateLimit.requests;\n    }\n    \n    /**\n     * 记录请求\n     */\n    recordRequest(key, _rateLimit) {\n        const now = Date.now();\n        const requests = this.rateLimiters.get(key) || [];\n        requests.push(now);\n        this.rateLimiters.set(key, requests);\n    }\n    \n    /**\n     * 创建错误响应\n     */\n    createErrorResponse(status, message, details = null) {\n        return {\n            status,\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: {\n                error: true,\n                message,\n                details,\n                timestamp: new Date().toISOString()\n            }\n        };\n    }\n    \n    /**\n     * 更新请求统计\n     */\n    updateRequestStats(route, startTime, status) {\n        const responseTime = Date.now() - startTime;\n        const { stats } = route;\n        \n        stats.requests++;\n        if (response.status >= HTTP_STATUS_CODES.BAD_REQUEST) {\n            stats.errors++;\n        }\n        \n        // 计算平均响应时间\n        stats.avgResponseTime = (stats.avgResponseTime * (stats.requests - 1) + responseTime) / stats.requests;\n        stats.lastAccess = new Date().toISOString();\n    }\n    \n    /**\n     * 启动监控\n     */\n    startMonitoring() {\n        // 每分钟清理过期的限流记录\n        setInterval(() => {\n            this.cleanupRateLimiters();\n        }, MATH_CONSTANTS.SIXTY * MATH_CONSTANTS.MILLISECONDS_PER_SECOND);\n        \n        // 每5分钟输出统计信息\n        setInterval(() => {\n            this.logStatistics();\n        }, MATH_CONSTANTS.FIVE * MATH_CONSTANTS.SIXTY * MATH_CONSTANTS.MILLISECONDS_PER_SECOND);\n    }\n    \n    /**\n     * 清理限流记录\n     */\n    cleanupRateLimiters() {\n        const now = Date.now();\n        const maxAge = MATH_CONSTANTS.SIXTY * MATH_CONSTANTS.MILLISECONDS_PER_SECOND; // 1分钟\n        \n        for (const [key, requests] of this.rateLimiters) {\n            const validRequests = requests.filter(timestamp => now - timestamp < maxAge);\n            if (validRequests.length === 0) {\n                this.rateLimiters.delete(key);\n            } else {\n                this.rateLimiters.set(key, validRequests);\n            }\n        }\n    }\n    \n    /**\n     * 输出统计信息\n     */\n    logStatistics() {\n        const stats = this.getGatewayStats();\n        logger.info('📊 API网关统计信息:', stats);\n        this.emit('gateway:stats', stats);\n    }\n    \n    /**\n     * 获取网关统计信息\n     */\n    getGatewayStats() {\n        const stats = {\n            totalRoutes: this.routes.size,\n            activeRateLimiters: this.rateLimiters.size,\n            serviceHealth: this.serviceRegistry.getServiceHealth(),\n            routeStats: {}\n        };\n        \n        for (const [path, route] of this.routes) {\n            stats.routeStats[path] = {\n                requests: route.stats.requests,\n                errors: route.stats.errors,\n                errorRate: route.stats.requests > MATH_CONSTANTS.ZERO ? (route.stats.errors / route.stats.requests * MATH_CONSTANTS.ONE_HUNDRED).toFixed(MATH_CONSTANTS.TWO) : MATH_CONSTANTS.ZERO,\n                avgResponseTime: Math.round(route.stats.avgResponseTime),\n                lastAccess: route.stats.lastAccess\n            };\n        }\n        \n        return stats;\n    }\n    \n    /**\n     * 获取健康状态\n     */\n    getHealthStatus() {\n        const serviceHealth = this.serviceRegistry.getServiceHealth();\n        const totalServices = Object.values(serviceHealth).reduce((sum, service) => sum + service.total, 0);\n        const healthyServices = Object.values(serviceHealth).reduce((sum, service) => sum + service.healthy, 0);\n        \n        return {\n            status: healthyServices === totalServices ? 'healthy' : 'degraded',\n            services: serviceHealth,\n            gateway: {\n                uptime: process.uptime(),\n                memory: process.memoryUsage(),\n                routes: this.routes.size,\n                activeConnections: this.rateLimiters.size\n            },\n            timestamp: new Date().toISOString()\n        };\n    }\n    \n    /**\n     * 添加路由\n     */\n    addRoute(path, config) {\n        this.routes.set(path, {\n            ...config,\n            stats: {\n                requests: 0,\n                errors: 0,\n                avgResponseTime: 0,\n                lastAccess: null\n            }\n        });\n        \n        logger.info(`➕ 添加路由: ${path} -> ${config.service}`);\n    }\n    \n    /**\n     * 移除路由\n     */\n    removeRoute(path) {\n        if (this.routes.delete(path)) {\n            logger.info(`➖ 移除路由: ${path}`);\n        }\n    }\n}\n\nexport default ApiGateway;","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]