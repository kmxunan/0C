[{"filePath":"/Users/xunan/Documents/WebStormProjects/0C/src/core/architecture/ApiGateway.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'status' is defined but never used. Allowed unused args must match /^_/u.","line":449,"column":42,"nodeType":"Identifier","messageId":"unusedVar","endLine":449,"endColumn":48},{"ruleId":"no-undef","severity":2,"message":"'response' is not defined.","line":454,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":454,"endColumn":21}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * APIç½‘å…³\n * é›¶ç¢³å›­åŒºæ•°å­—å­ªç”Ÿç³»ç»Ÿçš„ç»Ÿä¸€APIå…¥å£\n * æä¾›è·¯ç”±ã€è®¤è¯ã€é™æµã€ç›‘æŽ§ç­‰åŠŸèƒ½\n */\n\nimport { EventEmitter } from 'events';\nimport logger from '../../shared/utils/logger.js';\nimport ServiceRegistry from './ServiceRegistry.js';\nimport { MATH_CONSTANTS } from '../../shared/constants/MathConstants.js';\nimport { HTTP_STATUS_CODES } from '../../shared/constants/HttpStatusCodes.js';\n\nclass ApiGateway extends EventEmitter {\n    constructor() {\n        super();\n        this.serviceRegistry = new ServiceRegistry();\n        this.routes = new Map();\n        this.middlewares = [];\n        this.rateLimiters = new Map();\n        this.authTokens = new Map();\n        this.requestStats = new Map();\n        \n        // è·¯ç”±é…ç½®\n        this.routeConfig = {\n            '/api/v1/carbon': {\n                service: 'carbon-accounting-engine',\n                methods: ['GET', 'POST'],\n                auth: true,\n                rateLimit: { requests: 100, window: 60000 } // 100è¯·æ±‚/åˆ†é’Ÿ\n            },\n            '/api/v1/energy-flow': {\n                service: 'energy-flow-visualization',\n                methods: ['GET', 'POST'],\n                auth: true,\n                rateLimit: { requests: 50, window: 60000 }\n            },\n            '/api/v1/indicators': {\n                service: 'national-indicator-dashboard',\n                methods: ['GET', 'POST'],\n                auth: true,\n                rateLimit: { requests: 200, window: 60000 }\n            },\n            '/api/v1/green-electricity': {\n                service: 'green-electricity-tracing',\n                methods: ['GET', 'POST'],\n                auth: true,\n                rateLimit: { requests: 80, window: 60000 }\n            },\n            '/api/v1/reports': {\n                service: 'report-generator',\n                methods: ['GET', 'POST'],\n                auth: true,\n                rateLimit: { requests: 20, window: 60000 }\n            },\n            '/api/v1/integration': {\n                service: 'energy-carbon-integration',\n                methods: ['GET', 'POST'],\n                auth: true,\n                rateLimit: { requests: 150, window: 60000 }\n            }\n        };\n        \n        this.init();\n    }\n    \n    /**\n     * åˆå§‹åŒ–APIç½‘å…³\n     */\n    async init() {\n        try {\n            logger.info('ðŸš€ APIç½‘å…³å¯åŠ¨ä¸­...');\n            \n            // ç­‰å¾…æœåŠ¡æ³¨å†Œä¸­å¿ƒåˆå§‹åŒ–\n            await this.waitForServiceRegistry();\n            \n            // åˆå§‹åŒ–è·¯ç”±\n            this.initializeRoutes();\n            \n            // åˆå§‹åŒ–ä¸­é—´ä»¶\n            this.initializeMiddlewares();\n            \n            // å¯åŠ¨ç›‘æŽ§\n            this.startMonitoring();\n            \n            logger.info('âœ… APIç½‘å…³å¯åŠ¨å®Œæˆ');\n            this.emit('gateway:ready');\n        } catch (error) {\n            logger.error('APIç½‘å…³å¯åŠ¨å¤±è´¥:', error);\n            throw error;\n        }\n    }\n    \n    /**\n     * ç­‰å¾…æœåŠ¡æ³¨å†Œä¸­å¿ƒå°±ç»ª\n     */\n    async waitForServiceRegistry() {\n        return new Promise((resolve) => {\n            if (this.serviceRegistry.services.size > 0) {\n                resolve();\n            } else {\n                this.serviceRegistry.on('service:registered', () => {\n                    resolve();\n                });\n            }\n        });\n    }\n    \n    /**\n     * åˆå§‹åŒ–è·¯ç”±\n     */\n    initializeRoutes() {\n        for (const [path, config] of Object.entries(this.routeConfig)) {\n            this.routes.set(path, {\n                ...config,\n                stats: {\n                    requests: 0,\n                    errors: 0,\n                    avgResponseTime: 0,\n                    lastAccess: null\n                }\n            });\n        }\n        \n        logger.info(`ðŸ“‹ å·²é…ç½® ${this.routes.size} ä¸ªè·¯ç”±`);\n    }\n    \n    /**\n     * åˆå§‹åŒ–ä¸­é—´ä»¶\n     */\n    initializeMiddlewares() {\n        // è¯·æ±‚æ—¥å¿—ä¸­é—´ä»¶\n        this.use(this.requestLoggerMiddleware.bind(this));\n        \n        // è®¤è¯ä¸­é—´ä»¶\n        this.use(this.authenticationMiddleware.bind(this));\n        \n        // é™æµä¸­é—´ä»¶\n        this.use(this.rateLimitMiddleware.bind(this));\n        \n        // CORSä¸­é—´ä»¶\n        this.use(this.corsMiddleware.bind(this));\n        \n        // é”™è¯¯å¤„ç†ä¸­é—´ä»¶\n        this.use(this.errorHandlingMiddleware.bind(this));\n        \n        logger.info(`ðŸ”§ å·²åŠ è½½ ${this.middlewares.length} ä¸ªä¸­é—´ä»¶`);\n    }\n    \n    /**\n     * æ·»åŠ ä¸­é—´ä»¶\n     */\n    use(middleware) {\n        this.middlewares.push(middleware);\n    }\n    \n    /**\n     * å¤„ç†HTTPè¯·æ±‚\n     * @param {Object} request è¯·æ±‚å¯¹è±¡\n     * @returns {Object} å“åº”å¯¹è±¡\n     */\n    async handleRequest(request) {\n        const startTime = Date.now();\n        let response = {\n            status: 200,\n            headers: {},\n            body: null\n        };\n        \n        try {\n            // åˆ›å»ºè¯·æ±‚ä¸Šä¸‹æ–‡\n            const context = {\n                request,\n                response,\n                startTime,\n                route: null,\n                service: null,\n                user: null\n            };\n            \n            // è·¯ç”±åŒ¹é…\n            const route = this.matchRoute(request.path, request.method);\n            if (!route) {\n                return this.createErrorResponse(HTTP_STATUS_CODES.NOT_FOUND, 'è·¯ç”±ä¸å­˜åœ¨');\n            }\n            \n            context.route = route;\n            \n            // æ‰§è¡Œä¸­é—´ä»¶é“¾\n            for (const middleware of this.middlewares) {\n                const result = await middleware(context);\n                if (result && result.status) {\n                    return result; // ä¸­é—´ä»¶è¿”å›žå“åº”ï¼Œç»ˆæ­¢å¤„ç†\n                }\n            }\n            \n            // æœåŠ¡å‘çŽ°\n            const serviceInstance = this.serviceRegistry.discoverService(route.service);\n            if (!serviceInstance) {\n                return this.createErrorResponse(HTTP_STATUS_CODES.SERVICE_UNAVAILABLE, 'æœåŠ¡ä¸å¯ç”¨');\n            }\n            \n            context.service = serviceInstance;\n            \n            // è½¬å‘è¯·æ±‚åˆ°åŽç«¯æœåŠ¡\n            response = await this.forwardRequest(context);\n            \n            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯\n            this.updateRequestStats(route, startTime, response.status);\n            \n            return response;\n        } catch (error) {\n            logger.error('è¯·æ±‚å¤„ç†å¤±è´¥:', error);\n            return this.createErrorResponse(HTTP_STATUS_CODES.INTERNAL_SERVER_ERROR, 'å†…éƒ¨æœåŠ¡å™¨é”™è¯¯', error.message);\n        }\n    }\n    \n    /**\n     * è·¯ç”±åŒ¹é…\n     */\n    matchRoute(path, method) {\n        for (const [routePath, routeConfig] of this.routes) {\n            if (this.pathMatches(path, routePath) && routeConfig.methods.includes(method)) {\n                return { path: routePath, ...routeConfig };\n            }\n        }\n        return null;\n    }\n    \n    /**\n     * è·¯å¾„åŒ¹é…\n     */\n    pathMatches(requestPath, routePath) {\n        // ç®€å•çš„è·¯å¾„åŒ¹é…ï¼Œæ”¯æŒé€šé…ç¬¦\n        const routeRegex = routePath.replace(/\\*/g, '.*');\n        return new RegExp(`^${routeRegex}`).test(requestPath);\n    }\n    \n    /**\n     * è½¬å‘è¯·æ±‚åˆ°åŽç«¯æœåŠ¡\n     */\n    async forwardRequest(context) {\n        const { request, service } = context;\n        \n        try {\n            // æž„å»ºç›®æ ‡URL\n            const targetUrl = `http://${service.host}:${service.port}${request.path}`;\n            \n            // æ¨¡æ‹ŸHTTPè¯·æ±‚è½¬å‘\n            const response = await this.makeHttpRequest({\n                url: targetUrl,\n                method: request.method,\n                headers: request.headers,\n                body: request.body\n            });\n            \n            return response;\n        } catch (error) {\n            logger.error(`è¯·æ±‚è½¬å‘å¤±è´¥ (${service.name}):`, error);\n            throw error;\n        }\n    }\n    \n    /**\n     * æ¨¡æ‹ŸHTTPè¯·æ±‚\n     */\n    async makeHttpRequest(options) {\n        // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ\n        await new Promise(resolve => setTimeout(resolve, Math.random() * MATH_CONSTANTS.ONE_HUNDRED + MATH_CONSTANTS.FIFTY));\n        \n        // æ¨¡æ‹Ÿå“åº”\n        return {\n            status: 200,\n            headers: {\n                'Content-Type': 'application/json',\n                'X-Service-Name': 'mock-service'\n            },\n            body: {\n                success: true,\n                data: {\n                    message: 'æ¨¡æ‹Ÿå“åº”æ•°æ®',\n                    timestamp: new Date().toISOString(),\n                    requestPath: options.url\n                }\n            }\n        };\n    }\n    \n    /**\n     * è¯·æ±‚æ—¥å¿—ä¸­é—´ä»¶\n     */\n    async requestLoggerMiddleware(context) {\n        const { request } = context;\n        logger.info(`ðŸ“¥ ${request.method} ${request.path} - ${request.headers['user-agent'] || 'Unknown'}`);\n        \n        // è®°å½•è¯·æ±‚å¼€å§‹æ—¶é—´\n        context.requestStartTime = Date.now();\n    }\n    \n    /**\n     * è®¤è¯ä¸­é—´ä»¶\n     */\n    async authenticationMiddleware(context) {\n        const { request, route } = context;\n        \n        // å¦‚æžœè·¯ç”±ä¸éœ€è¦è®¤è¯ï¼Œè·³è¿‡\n        if (!route.auth) {\n            return;\n        }\n        \n        const authHeader = request.headers.authorization;\n        if (!authHeader || !authHeader.startsWith('Bearer ')) {\n            return this.createErrorResponse(HTTP_STATUS_CODES.UNAUTHORIZED, 'ç¼ºå°‘è®¤è¯ä»¤ç‰Œ');\n        }\n        \n        const token = authHeader.substring(MATH_CONSTANTS.SEVEN);\n        const user = this.validateToken(token);\n        \n        if (!user) {\n            return this.createErrorResponse(HTTP_STATUS_CODES.UNAUTHORIZED, 'æ— æ•ˆçš„è®¤è¯ä»¤ç‰Œ');\n        }\n        \n        context.user = user;\n        logger.debug(`ðŸ” ç”¨æˆ·è®¤è¯æˆåŠŸ: ${user.username}`);\n    }\n    \n    /**\n     * é™æµä¸­é—´ä»¶\n     */\n    async rateLimitMiddleware(context) {\n        const { request, route } = context;\n        \n        if (!route.rateLimit) {\n            return;\n        }\n        \n        const clientId = this.getClientId(request);\n        const rateLimitKey = `${route.path}:${clientId}`;\n        \n        if (this.isRateLimited(rateLimitKey, route.rateLimit)) {\n            return this.createErrorResponse(HTTP_STATUS_CODES.TOO_MANY_REQUESTS, 'è¯·æ±‚é¢‘çŽ‡è¶…é™');\n        }\n        \n        this.recordRequest(rateLimitKey, route.rateLimit);\n    }\n    \n    /**\n     * CORSä¸­é—´ä»¶\n     */\n    async corsMiddleware(context) {\n        const { response } = context;\n        \n        response.headers['Access-Control-Allow-Origin'] = '*';\n        response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS';\n        response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization';\n    }\n    \n    /**\n     * é”™è¯¯å¤„ç†ä¸­é—´ä»¶\n     */\n    async errorHandlingMiddleware(context) {\n        // åœ¨è¯·æ±‚å®ŒæˆåŽæ‰§è¡Œ\n        const { response } = context;\n        \n        if (response.status >= HTTP_STATUS_CODES.BAD_REQUEST) {\n            logger.warn(`âš ï¸ è¯·æ±‚é”™è¯¯: ${response.status} - ${context.request.path}`);\n            this.emit('request:error', {\n                path: context.request.path,\n                status: response.status,\n                timestamp: new Date().toISOString()\n            });\n        }\n    }\n    \n    /**\n     * éªŒè¯ä»¤ç‰Œ\n     */\n    validateToken(token) {\n        // æ¨¡æ‹Ÿä»¤ç‰ŒéªŒè¯\n        const validTokens = {\n            'admin-token-123': { username: 'admin', role: 'administrator' },\n            'user-token-456': { username: 'user', role: 'operator' },\n            'readonly-token-789': { username: 'readonly', role: 'viewer' }\n        };\n        \n        return validTokens[token] || null;\n    }\n    \n    /**\n     * èŽ·å–å®¢æˆ·ç«¯ID\n     */\n    getClientId(request) {\n        return request.headers['x-client-id'] || \n               request.headers['x-forwarded-for'] || \n               request.connection?.remoteAddress || \n               'unknown';\n    }\n    \n    /**\n     * æ£€æŸ¥æ˜¯å¦è¢«é™æµ\n     */\n    isRateLimited(key, rateLimit) {\n        const now = Date.now();\n        const windowStart = now - rateLimit.window;\n        \n        if (!this.rateLimiters.has(key)) {\n            this.rateLimiters.set(key, []);\n        }\n        \n        const requests = this.rateLimiters.get(key);\n        \n        // æ¸…ç†è¿‡æœŸçš„è¯·æ±‚è®°å½•\n        const validRequests = requests.filter(timestamp => timestamp > windowStart);\n        this.rateLimiters.set(key, validRequests);\n        \n        return validRequests.length >= rateLimit.requests;\n    }\n    \n    /**\n     * è®°å½•è¯·æ±‚\n     */\n    recordRequest(key, _rateLimit) {\n        const now = Date.now();\n        const requests = this.rateLimiters.get(key) || [];\n        requests.push(now);\n        this.rateLimiters.set(key, requests);\n    }\n    \n    /**\n     * åˆ›å»ºé”™è¯¯å“åº”\n     */\n    createErrorResponse(status, message, details = null) {\n        return {\n            status,\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: {\n                error: true,\n                message,\n                details,\n                timestamp: new Date().toISOString()\n            }\n        };\n    }\n    \n    /**\n     * æ›´æ–°è¯·æ±‚ç»Ÿè®¡\n     */\n    updateRequestStats(route, startTime, status) {\n        const responseTime = Date.now() - startTime;\n        const { stats } = route;\n        \n        stats.requests++;\n        if (response.status >= HTTP_STATUS_CODES.BAD_REQUEST) {\n            stats.errors++;\n        }\n        \n        // è®¡ç®—å¹³å‡å“åº”æ—¶é—´\n        stats.avgResponseTime = (stats.avgResponseTime * (stats.requests - 1) + responseTime) / stats.requests;\n        stats.lastAccess = new Date().toISOString();\n    }\n    \n    /**\n     * å¯åŠ¨ç›‘æŽ§\n     */\n    startMonitoring() {\n        // æ¯åˆ†é’Ÿæ¸…ç†è¿‡æœŸçš„é™æµè®°å½•\n        setInterval(() => {\n            this.cleanupRateLimiters();\n        }, MATH_CONSTANTS.SIXTY * MATH_CONSTANTS.MILLISECONDS_PER_SECOND);\n        \n        // æ¯5åˆ†é’Ÿè¾“å‡ºç»Ÿè®¡ä¿¡æ¯\n        setInterval(() => {\n            this.logStatistics();\n        }, MATH_CONSTANTS.FIVE * MATH_CONSTANTS.SIXTY * MATH_CONSTANTS.MILLISECONDS_PER_SECOND);\n    }\n    \n    /**\n     * æ¸…ç†é™æµè®°å½•\n     */\n    cleanupRateLimiters() {\n        const now = Date.now();\n        const maxAge = MATH_CONSTANTS.SIXTY * MATH_CONSTANTS.MILLISECONDS_PER_SECOND; // 1åˆ†é’Ÿ\n        \n        for (const [key, requests] of this.rateLimiters) {\n            const validRequests = requests.filter(timestamp => now - timestamp < maxAge);\n            if (validRequests.length === 0) {\n                this.rateLimiters.delete(key);\n            } else {\n                this.rateLimiters.set(key, validRequests);\n            }\n        }\n    }\n    \n    /**\n     * è¾“å‡ºç»Ÿè®¡ä¿¡æ¯\n     */\n    logStatistics() {\n        const stats = this.getGatewayStats();\n        logger.info('ðŸ“Š APIç½‘å…³ç»Ÿè®¡ä¿¡æ¯:', stats);\n        this.emit('gateway:stats', stats);\n    }\n    \n    /**\n     * èŽ·å–ç½‘å…³ç»Ÿè®¡ä¿¡æ¯\n     */\n    getGatewayStats() {\n        const stats = {\n            totalRoutes: this.routes.size,\n            activeRateLimiters: this.rateLimiters.size,\n            serviceHealth: this.serviceRegistry.getServiceHealth(),\n            routeStats: {}\n        };\n        \n        for (const [path, route] of this.routes) {\n            stats.routeStats[path] = {\n                requests: route.stats.requests,\n                errors: route.stats.errors,\n                errorRate: route.stats.requests > MATH_CONSTANTS.ZERO ? (route.stats.errors / route.stats.requests * MATH_CONSTANTS.ONE_HUNDRED).toFixed(MATH_CONSTANTS.TWO) : MATH_CONSTANTS.ZERO,\n                avgResponseTime: Math.round(route.stats.avgResponseTime),\n                lastAccess: route.stats.lastAccess\n            };\n        }\n        \n        return stats;\n    }\n    \n    /**\n     * èŽ·å–å¥åº·çŠ¶æ€\n     */\n    getHealthStatus() {\n        const serviceHealth = this.serviceRegistry.getServiceHealth();\n        const totalServices = Object.values(serviceHealth).reduce((sum, service) => sum + service.total, 0);\n        const healthyServices = Object.values(serviceHealth).reduce((sum, service) => sum + service.healthy, 0);\n        \n        return {\n            status: healthyServices === totalServices ? 'healthy' : 'degraded',\n            services: serviceHealth,\n            gateway: {\n                uptime: process.uptime(),\n                memory: process.memoryUsage(),\n                routes: this.routes.size,\n                activeConnections: this.rateLimiters.size\n            },\n            timestamp: new Date().toISOString()\n        };\n    }\n    \n    /**\n     * æ·»åŠ è·¯ç”±\n     */\n    addRoute(path, config) {\n        this.routes.set(path, {\n            ...config,\n            stats: {\n                requests: 0,\n                errors: 0,\n                avgResponseTime: 0,\n                lastAccess: null\n            }\n        });\n        \n        logger.info(`âž• æ·»åŠ è·¯ç”±: ${path} -> ${config.service}`);\n    }\n    \n    /**\n     * ç§»é™¤è·¯ç”±\n     */\n    removeRoute(path) {\n        if (this.routes.delete(path)) {\n            logger.info(`âž– ç§»é™¤è·¯ç”±: ${path}`);\n        }\n    }\n}\n\nexport default ApiGateway;","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]