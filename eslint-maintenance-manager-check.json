[{"filePath":"/Users/xunan/Documents/WebStormProjects/0C/src/core/services/MaintenanceManager.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'TIME_INTERVALS' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":40},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0.4.","line":718,"column":57,"nodeType":"Literal","messageId":"noMagic","endLine":718,"endColumn":60},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0.1.","line":724,"column":46,"nodeType":"Literal","messageId":"noMagic","endLine":724,"endColumn":49},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0.3.","line":724,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":724,"endColumn":54},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 8000.","line":733,"column":22,"nodeType":"Literal","messageId":"noMagic","endLine":733,"endColumn":26},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0.2.","line":735,"column":22,"nodeType":"Literal","messageId":"noMagic","endLine":735,"endColumn":25},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0.6.","line":752,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":752,"endColumn":55},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0.7.","line":765,"column":47,"nodeType":"Literal","messageId":"noMagic","endLine":765,"endColumn":50},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 80.","line":775,"column":82,"nodeType":"Literal","messageId":"noMagic","endLine":775,"endColumn":84},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0.3.","line":780,"column":53,"nodeType":"Literal","messageId":"noMagic","endLine":780,"endColumn":56},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 10.","line":854,"column":49,"nodeType":"Literal","messageId":"noMagic","endLine":854,"endColumn":51},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":922,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":922,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[25779,25808],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { dbPromise } from '../../infrastructure/database/index.js';\nimport { v4 as uuidv4 } from 'uuid';\nimport { MATH_CONSTANTS, TIME_INTERVALS } from '../../shared/constants/MathConstants.js';\nimport { defaultLogger as logger } from '../../utils/logger.js';\n\n/**\n * 智能运维管理模块\n * 提供设备故障预测、维护计划管理、运维优化等功能\n */\nclass MaintenanceManager {\n  // TODO: 考虑将此函数拆分为更小的函数 (当前 37 行)\n\n  // TODO: 考虑将此函数拆分为更小的函数 (当前 37 行)\n\n  // TODO: 考虑将此函数拆分为更小的函数 (当前 37 行)\n\n  // TODO: 考虑将此函数拆分为更小的函数 (当前 37 行)\n\n  constructor() {\n    this.cache = new Map();\n    this.cacheTimeout = MATH_CONSTANTS.FIFTEEN * MATH_CONSTANTS.SECONDS_PER_MINUTE * MATH_CONSTANTS.MILLISECONDS_PER_SECOND; // 15分钟缓存\n\n    // 设备健康度评分权重\n    this.healthWeights = {\n      performance: MATH_CONSTANTS.POINT_THREE, // 性能指标\n      reliability: MATH_CONSTANTS.POINT_TWO_FIVE, // 可靠性\n      efficiency: MATH_CONSTANTS.POINT_TWO, // 效率\n      safety: MATH_CONSTANTS.ZERO_POINT_FIFTEEN, // 安全性\n      maintenance: MATH_CONSTANTS.POINT_ONE // 维护状态\n    };\n\n    // 故障预测模型参数\n    this.predictionModels = {\n      temperature: {\n        threshold: MATH_CONSTANTS.EIGHTY, // 温度阈值\n        weight: MATH_CONSTANTS.POINT_THREE\n      },\n      vibration: {\n        threshold: MATH_CONSTANTS.FIVE, // 振动阈值\n        weight: MATH_CONSTANTS.POINT_TWO_FIVE\n      },\n      energy_efficiency: {\n        threshold: MATH_CONSTANTS.POINT_SEVEN, // 效率阈值\n        weight: MATH_CONSTANTS.POINT_TWO\n      },\n      runtime: {\n        threshold: MATH_CONSTANTS.EIGHT_THOUSAND_SEVEN_HUNDRED_SIXTY, // 年运行小时数\n        weight: MATH_CONSTANTS.ZERO_POINT_FIFTEEN\n      },\n      error_rate: {\n        threshold: MATH_CONSTANTS.POINT_ZERO_FIVE, // 错误率阈值\n        weight: MATH_CONSTANTS.POINT_ONE\n      }\n    };\n  }\n\n  /**\n   * 设备健康度评估\n   */\n  async assessDeviceHealth(deviceId, timeRange = '7d') {\n    try {\n      const cacheKey = `device_health_${deviceId}_${timeRange}`;\n      const cached = this.getFromCache(cacheKey);\n      if (cached) {\n        return cached;\n      }\n\n      const timeCondition = this.getTimeCondition(timeRange);\n\n      // 获取设备基本信息\n      const deviceInfo = await this.getDeviceInfo(deviceId);\n      if (!deviceInfo) {\n        throw new Error('设备不存在');\n      }\n\n      // 获取设备运行数据\n      const performanceData = await this.getDevicePerformanceData(deviceId, timeCondition);\n      const sensorData = await this.getDeviceSensorData(deviceId, timeCondition);\n      const maintenanceHistory = await this.getMaintenanceHistory(deviceId);\n\n      // 计算各项健康指标\n      const healthMetrics = {\n        performance: this.calculatePerformanceScore(performanceData),\n        reliability: this.calculateReliabilityScore(deviceId, timeCondition),\n        efficiency: this.calculateEfficiencyScore(performanceData),\n        safety: this.calculateSafetyScore(sensorData),\n        maintenance: this.calculateMaintenanceScore(maintenanceHistory)\n      };\n\n      // 计算综合健康度\n      const overallHealth = Object.entries(healthMetrics).reduce(\n        (total, [key, score]) => total + score * this.healthWeights[key],\n        MATH_CONSTANTS.ZERO\n      );\n\n      // 生成健康度等级\n      const healthLevel = this.getHealthLevel(overallHealth);\n\n      // 识别风险因素\n      const riskFactors = this.identifyRiskFactors(healthMetrics, sensorData);\n\n      // 生成建议\n      const recommendations = this.generateHealthRecommendations(healthMetrics, riskFactors);\n\n      const result = {\n        device_id: deviceId,\n        device_name: deviceInfo.name,\n        device_type: deviceInfo.type,\n        assessment_time: new Date().toISOString(),\n        time_range: timeRange,\n        overall_health: Math.round(overallHealth * MATH_CONSTANTS.ONE_HUNDRED) / MATH_CONSTANTS.ONE_HUNDRED,\n        health_level: healthLevel,\n        health_metrics: healthMetrics,\n        risk_factors: riskFactors,\n        recommendations,\n        next_assessment: this.calculateNextAssessment(healthLevel)\n      };\n\n      this.setCache(cacheKey, result);\n      return result;\n    } catch (error) {\n      logger.error('设备健康度评估失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 故障预测\n   */\n  async predictDeviceFailure(deviceId, predictionDays = MATH_CONSTANTS.THIRTY) {\n    try {\n      const cacheKey = `failure_prediction_${deviceId}_${predictionDays}`;\n      const cached = this.getFromCache(cacheKey);\n      if (cached) {\n        return cached;\n      }\n\n      // 获取历史数据\n      const historicalData = await this.getHistoricalData(deviceId, '90d');\n      const maintenanceHistory = await this.getMaintenanceHistory(deviceId);\n      const currentHealth = await this.assessDeviceHealth(deviceId, '7d');\n\n      // 计算故障概率\n      const failureProbability = this.calculateFailureProbability(\n        historicalData,\n        maintenanceHistory,\n        currentHealth\n      );\n\n      // 预测可能的故障类型\n      const potentialFailures = this.predictFailureTypes(historicalData, currentHealth);\n\n      // 计算预计故障时间\n      const estimatedFailureTime = this.estimateFailureTime(\n        failureProbability,\n        currentHealth.overall_health,\n        predictionDays\n      );\n\n      // 生成预防措施建议\n      const preventiveMeasures = this.generatePreventiveMeasures(potentialFailures, currentHealth);\n\n      const result = {\n        device_id: deviceId,\n        prediction_date: new Date().toISOString(),\n        prediction_period: predictionDays,\n        failure_probability: Math.round(failureProbability * MATH_CONSTANTS.ONE_HUNDRED) / MATH_CONSTANTS.ONE_HUNDRED,\n        risk_level: this.getRiskLevel(failureProbability),\n        estimated_failure_time: estimatedFailureTime,\n        potential_failures: potentialFailures,\n        preventive_measures: preventiveMeasures,\n        confidence_score: this.calculatePredictionConfidence(historicalData),\n        current_health: currentHealth.overall_health\n      };\n\n      this.setCache(cacheKey, result);\n      return result;\n    } catch (error) {\n      logger.error('故障预测失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 创建维护计划\n   */\n  async createMaintenancePlan(params) {\n    try {\n      const {\n        deviceId,\n        planType,\n        priority,\n        scheduledDate,\n        estimatedDuration,\n        description,\n        requiredSkills = [],\n        requiredParts = [],\n        assignedTechnician\n      } = params;\n\n      // 验证必填字段\n      if (!deviceId || !planType || !scheduledDate) {\n        throw new Error('缺少必填字段');\n      }\n\n      // 验证计划类型\n      const validTypes = ['preventive', 'corrective', 'predictive', 'emergency'];\n      if (!validTypes.includes(planType)) {\n        throw new Error('无效的维护计划类型');\n      }\n\n      const planId = uuidv4();\n\n      const sql = `\n        INSERT INTO maintenance_plans (\n          id, device_id, plan_type, priority, scheduled_date,\n          estimated_duration, description, required_skills,\n          required_parts, assigned_technician, status, created_at\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'scheduled', datetime('now'))\n      `;\n\n      await this.runDatabase(sql, [\n        planId,\n        deviceId,\n        planType,\n        priority || 'medium',\n        scheduledDate,\n        estimatedDuration || MATH_CONSTANTS.ONE_HUNDRED_TWENTY, // 默认2小时\n        description,\n        JSON.stringify(requiredSkills),\n        JSON.stringify(requiredParts),\n        assignedTechnician\n      ]);\n\n      // 如果是预测性维护，更新设备健康状态\n      if (planType === 'predictive') {\n        await this.updateDeviceMaintenanceStatus(deviceId, 'maintenance_scheduled');\n      }\n\n      return {\n        id: planId,\n        device_id: deviceId,\n        plan_type: planType,\n        priority,\n        scheduled_date: scheduledDate,\n        estimated_duration: estimatedDuration,\n        description,\n        required_skills: requiredSkills,\n        required_parts: requiredParts,\n        assigned_technician: assignedTechnician,\n        status: 'scheduled'\n      };\n    } catch (error) {\n      logger.error('创建维护计划失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 智能维护调度\n   */\n  async scheduleMaintenanceOptimization(params = {}) {\n    try {\n      const {\n        timeRange = '30d',\n        maxConcurrentMaintenance = MATH_CONSTANTS.THREE,\n        technicianAvailability = {},\n        priorityWeights = { emergency: MATH_CONSTANTS.ONE, high: MATH_CONSTANTS.POINT_EIGHT, medium: MATH_CONSTANTS.POINT_SIX, low: MATH_CONSTANTS.POINT_FOUR }\n      } = params;\n\n      // 获取待调度的维护计划\n      const pendingPlans = await this.getPendingMaintenancePlans(timeRange);\n\n      // 获取技师可用性\n      const technicianSchedule = await this.getTechnicianSchedule(timeRange);\n\n      // 获取设备优先级\n      const devicePriorities = await this.getDevicePriorities();\n\n      // 执行调度优化算法\n      const optimizedSchedule = this.optimizeMaintenanceSchedule(\n        pendingPlans,\n        technicianSchedule,\n        devicePriorities,\n        {\n          maxConcurrentMaintenance,\n          priorityWeights,\n          technicianAvailability\n        }\n      );\n\n      // 计算调度效果指标\n      const scheduleMetrics = this.calculateScheduleMetrics(optimizedSchedule, pendingPlans);\n\n      return {\n        optimization_date: new Date().toISOString(),\n        time_range: timeRange,\n        total_plans: pendingPlans.length,\n        optimized_schedule: optimizedSchedule,\n        metrics: scheduleMetrics,\n        recommendations: this.generateScheduleRecommendations(optimizedSchedule)\n      };\n    } catch (error) {\n      logger.error('维护调度优化失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 维护成本分析\n   */\n  async analyzeMaintenanceCosts(scope, scopeId, timeRange = '365d') {\n    try {\n      const cacheKey = `maintenance_costs_${scope}_${scopeId}_${timeRange}`;\n      const cached = this.getFromCache(cacheKey);\n      if (cached) {\n        return cached;\n      }\n\n      const timeCondition = this.getTimeCondition(timeRange);\n\n      // 获取维护记录\n      const maintenanceRecords = await this.getMaintenanceRecords(scope, scopeId, timeCondition);\n\n      // 计算各类成本\n      const costBreakdown = {\n        labor_cost: 0,\n        parts_cost: 0,\n        downtime_cost: 0,\n        emergency_cost: 0,\n        total_cost: 0\n      };\n\n      const maintenanceStats = {\n        total_maintenance: maintenanceRecords.length,\n        preventive_count: 0,\n        corrective_count: 0,\n        emergency_count: 0,\n        average_duration: 0,\n        total_downtime: 0\n      };\n\n      let totalDuration = 0;\n\n      for (const record of maintenanceRecords) {\n        // 计算人工成本\n        const laborCost =\n          (record.actual_duration || record.estimated_duration || 0) *\n          (record.technician_hourly_rate || MATH_CONSTANTS.FIFTY);\n        costBreakdown.labor_cost += laborCost;\n\n        // 计算配件成本\n        const partsCost = record.parts_cost || 0;\n        costBreakdown.parts_cost += partsCost;\n\n        // 计算停机成本\n        const downtimeCost = (record.downtime_hours || MATH_CONSTANTS.ZERO) * (record.downtime_hourly_cost || MATH_CONSTANTS.ONE_HUNDRED);\n        costBreakdown.downtime_cost += downtimeCost;\n\n        // 紧急维护额外成本\n        if (record.plan_type === 'emergency') {\n          const emergencyCost = laborCost * MATH_CONSTANTS.POINT_FIVE; // 紧急维护额外50%成本\n          costBreakdown.emergency_cost += emergencyCost;\n          maintenanceStats.emergency_count++;\n        }\n\n        // 统计维护类型\n        if (record.plan_type === 'preventive') {\n          maintenanceStats.preventive_count++;\n        } else if (record.plan_type === 'corrective') {\n          maintenanceStats.corrective_count++;\n        }\n\n        totalDuration += record.actual_duration || record.estimated_duration || MATH_CONSTANTS.ZERO;\n        maintenanceStats.total_downtime += record.downtime_hours || MATH_CONSTANTS.ZERO;\n      }\n\n      costBreakdown.total_cost =\n        Object.values(costBreakdown).reduce((sum, cost) => sum + cost, MATH_CONSTANTS.ZERO) -\n        costBreakdown.total_cost;\n      maintenanceStats.average_duration =\n        maintenanceRecords.length > MATH_CONSTANTS.ZERO ? totalDuration / maintenanceRecords.length : MATH_CONSTANTS.ZERO;\n\n      // 计算成本趋势\n      const costTrend = await this.calculateCostTrend(scope, scopeId, timeRange);\n\n      // 成本优化建议\n      const optimizationSuggestions = this.generateCostOptimizationSuggestions(\n        costBreakdown,\n        maintenanceStats\n      );\n\n      const result = {\n        scope,\n        scope_id: scopeId,\n        time_range: timeRange,\n        cost_breakdown: costBreakdown,\n        maintenance_stats: maintenanceStats,\n        cost_trend: costTrend,\n        cost_per_device: this.calculateCostPerDevice(costBreakdown.total_cost, scope, scopeId),\n        optimization_suggestions: optimizationSuggestions,\n        analysis_date: new Date().toISOString()\n      };\n\n      this.setCache(cacheKey, result);\n      return result;\n    } catch (error) {\n      logger.error('维护成本分析失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 生成维护报告\n   */\n  async generateMaintenanceReport(params) {\n    try {\n      const {\n        scope,\n        scopeId,\n        reportType = 'comprehensive',\n        timeRange = '30d',\n        includeForecasting = true\n      } = params;\n\n      const reportId = uuidv4();\n\n      // 收集报告数据\n      const reportData = {\n        basic_info: await this.getBasicInfo(scope, scopeId),\n        health_assessment: await this.getHealthAssessmentSummary(scope, scopeId, timeRange),\n        maintenance_summary: await this.getMaintenanceSummary(scope, scopeId, timeRange),\n        cost_analysis: await this.analyzeMaintenanceCosts(scope, scopeId, timeRange),\n        performance_metrics: await this.getPerformanceMetrics(scope, scopeId, timeRange)\n      };\n\n      if (includeForecasting) {\n        reportData.forecasting = await this.getMaintenanceForecasting(scope, scopeId);\n      }\n\n      // 生成报告内容\n      const reportContent = this.compileMaintenanceReport(reportData, reportType);\n\n      // 保存报告\n      const sql = `\n        INSERT INTO maintenance_reports (\n          id, scope, scope_id, report_type, time_range,\n          content, created_at\n        ) VALUES (?, ?, ?, ?, ?, ?, datetime('now'))\n      `;\n\n      await this.runDatabase(sql, [\n        reportId,\n        scope,\n        scopeId,\n        reportType,\n        timeRange,\n        JSON.stringify(reportContent)\n      ]);\n\n      return {\n        id: reportId,\n        scope,\n        scope_id: scopeId,\n        report_type: reportType,\n        time_range: timeRange,\n        content: reportContent,\n        generated_at: new Date().toISOString()\n      };\n    } catch (error) {\n      logger.error('生成维护报告失败:', error);\n      throw error;\n    }\n  }\n\n  // ==================== 辅助计算方法 ====================\n\n  /**\n   * 计算性能评分\n   */\n  calculatePerformanceScore(performanceData) {\n    if (!performanceData || performanceData.length === 0) {\n      return MATH_CONSTANTS.POINT_FIVE;\n    }\n\n    const avgEfficiency =\n      performanceData.reduce((sum, data) => sum + (data.efficiency || MATH_CONSTANTS.POINT_EIGHT), MATH_CONSTANTS.ZERO) /\n      performanceData.length;\n    const avgUptime =\n      performanceData.reduce((sum, data) => sum + (data.uptime || MATH_CONSTANTS.POINT_NINE_FIVE), MATH_CONSTANTS.ZERO) /\n      performanceData.length;\n\n    return avgEfficiency * MATH_CONSTANTS.POINT_SIX + avgUptime * MATH_CONSTANTS.POINT_FOUR;\n  }\n\n  /**\n   * 计算可靠性评分\n   */\n  async calculateReliabilityScore(deviceId, timeCondition) {\n    try {\n      const sql = `\n        SELECT COUNT(*) as failure_count\n        FROM maintenance_records\n        WHERE device_id = ? AND plan_type IN ('corrective', 'emergency')\n        AND completed_date >= datetime('now', ?)\n      `;\n\n      const result = await this.queryDatabase(sql, [deviceId, timeCondition]);\n      const failureCount = result[0]?.failure_count || 0;\n\n      // 基于故障次数计算可靠性评分\n      return Math.max(MATH_CONSTANTS.ZERO, MATH_CONSTANTS.ONE - failureCount * MATH_CONSTANTS.POINT_ONE);\n    } catch (error) {\n      logger.error('计算可靠性评分失败:', error);\n      return MATH_CONSTANTS.POINT_FIVE;\n    }\n  }\n\n  /**\n   * 计算效率评分\n   */\n  calculateEfficiencyScore(performanceData) {\n    if (!performanceData || performanceData.length === 0) {\n      return MATH_CONSTANTS.POINT_FIVE;\n    }\n\n    const avgEnergyEfficiency =\n      performanceData.reduce((sum, data) => sum + (data.energy_efficiency || MATH_CONSTANTS.POINT_EIGHT), MATH_CONSTANTS.ZERO) /\n      performanceData.length;\n\n    return avgEnergyEfficiency;\n  }\n\n  /**\n   * 计算安全评分\n   */\n  calculateSafetyScore(sensorData) {\n    if (!sensorData || sensorData.length === 0) {\n      return MATH_CONSTANTS.POINT_EIGHT;\n    }\n\n    let safetyScore = MATH_CONSTANTS.ONE;\n\n    for (const data of sensorData) {\n      // 检查温度异常\n      if (data.temperature > MATH_CONSTANTS.EIGHTY) {\n        safetyScore -= MATH_CONSTANTS.POINT_ONE;\n      }\n\n      // 检查振动异常\n      if (data.vibration > MATH_CONSTANTS.FIVE) {\n        safetyScore -= MATH_CONSTANTS.POINT_ONE;\n      }\n\n      // 检查其他安全指标\n      if (data.pressure && data.pressure > data.max_pressure) {\n        safetyScore -= MATH_CONSTANTS.ZERO_POINT_FIFTEEN;\n      }\n    }\n\n    return Math.max(MATH_CONSTANTS.ZERO, safetyScore);\n  }\n\n  /**\n   * 计算维护评分\n   */\n  calculateMaintenanceScore(maintenanceHistory) {\n    if (!maintenanceHistory || maintenanceHistory.length === 0) {\n      return MATH_CONSTANTS.POINT_FIVE;\n    }\n\n    const now = new Date();\n    const lastMaintenance = new Date(maintenanceHistory[0].completed_date);\n    const daysSinceLastMaintenance = (now - lastMaintenance) / (MATH_CONSTANTS.MILLISECONDS_PER_SECOND * MATH_CONSTANTS.SECONDS_PER_MINUTE * MATH_CONSTANTS.MINUTES_PER_HOUR * MATH_CONSTANTS.HOURS_PER_DAY);\n\n    // 基于最后维护时间计算评分\n    if (daysSinceLastMaintenance < MATH_CONSTANTS.THIRTY) {\n      return MATH_CONSTANTS.ONE;\n    }\n    if (daysSinceLastMaintenance < MATH_CONSTANTS.SIXTY) {\n      return MATH_CONSTANTS.POINT_EIGHT;\n    }\n    if (daysSinceLastMaintenance < MATH_CONSTANTS.NINETY) {\n      return MATH_CONSTANTS.POINT_SIX;\n    }\n    if (daysSinceLastMaintenance < MATH_CONSTANTS.ONE_HUNDRED_EIGHTY) {\n      return MATH_CONSTANTS.POINT_FOUR;\n    }\n    return MATH_CONSTANTS.POINT_TWO;\n  }\n\n  /**\n   * 获取健康度等级\n   */\n  getHealthLevel(score) {\n    if (score >= MATH_CONSTANTS.POINT_NINE) {\n      return 'excellent';\n    }\n    if (score >= MATH_CONSTANTS.POINT_EIGHT) {\n      return 'good';\n    }\n    if (score >= MATH_CONSTANTS.POINT_SEVEN) {\n      return 'fair';\n    }\n    if (score >= MATH_CONSTANTS.POINT_SIX) {\n      return 'poor';\n    }\n    return 'critical';\n  }\n\n  /**\n   * 识别风险因素\n   */\n  identifyRiskFactors(healthMetrics, sensorData) {\n    const riskFactors = [];\n\n    // 检查各项健康指标\n    Object.entries(healthMetrics).forEach(([metric, score]) => {\n      if (score < MATH_CONSTANTS.POINT_SIX) {\n        riskFactors.push({\n          type: 'health_metric',\n          metric,\n          score,\n          severity: score < MATH_CONSTANTS.POINT_FOUR ? 'high' : 'medium',\n          description: `${metric}指标偏低`\n        });\n      }\n    });\n\n    // 检查传感器数据异常\n    if (sensorData && sensorData.length > MATH_CONSTANTS.ZERO) {\n      const latestData = sensorData[sensorData.length - MATH_CONSTANTS.ONE];\n\n      if (latestData.temperature > MATH_CONSTANTS.EIGHTY) {\n        riskFactors.push({\n          type: 'sensor_anomaly',\n          metric: 'temperature',\n          value: latestData.temperature,\n          severity: 'high',\n          description: '设备温度过高'\n        });\n      }\n\n      if (latestData.vibration > MATH_CONSTANTS.FIVE) {\n        riskFactors.push({\n          type: 'sensor_anomaly',\n          metric: 'vibration',\n          value: latestData.vibration,\n          severity: 'medium',\n          description: '设备振动异常'\n        });\n      }\n    }\n\n    return riskFactors;\n  }\n\n  /**\n   * 生成健康建议\n   */\n  generateHealthRecommendations(healthMetrics, riskFactors) {\n    const recommendations = [];\n\n    // 基于健康指标生成建议\n    if (healthMetrics.performance < MATH_CONSTANTS.POINT_SEVEN) {\n      recommendations.push({\n        type: 'performance',\n        priority: 'high',\n        action: '性能优化',\n        description: '建议进行设备性能调优和清洁维护'\n      });\n    }\n\n    if (healthMetrics.reliability < MATH_CONSTANTS.POINT_SIX) {\n      recommendations.push({\n        type: 'reliability',\n        priority: 'high',\n        action: '可靠性提升',\n        description: '建议检查关键部件并进行预防性维护'\n      });\n    }\n\n    if (healthMetrics.maintenance < MATH_CONSTANTS.POINT_FIVE) {\n      recommendations.push({\n        type: 'maintenance',\n        priority: 'medium',\n        action: '定期维护',\n        description: '建议制定并执行定期维护计划'\n      });\n    }\n\n    // 基于风险因素生成建议\n    riskFactors.forEach((risk) => {\n      // TODO: 考虑使用早期返回或策略模式来减少嵌套\n      // TODO: 考虑使用早期返回或策略模式来减少嵌套\n      // TODO: 考虑使用早期返回或策略模式来减少嵌套\n      // TODO: 考虑使用早期返回或策略模式来减少嵌套\n      if (risk.severity === 'high') {\n        recommendations.push({\n          type: 'risk_mitigation',\n          priority: 'urgent',\n          action: '风险缓解',\n          description: `紧急处理${risk.description}`\n        });\n      }\n    });\n\n    return recommendations;\n  }\n\n  /**\n   * 计算故障概率\n   */\n  calculateFailureProbability(historicalData, maintenanceHistory, currentHealth) {\n    let probability = 0;\n\n    // 基于健康度计算基础概率\n    probability += (1 - currentHealth.overall_health) * 0.4;\n\n    // 基于历史故障频率\n    const recentFailures = maintenanceHistory.filter(\n      (record) => record.plan_type === 'corrective' || record.plan_type === 'emergency'\n    ).length;\n    probability += Math.min(recentFailures * 0.1, 0.3);\n\n    // 基于设备运行时间\n    const avgRuntime =\n      historicalData.reduce((sum, data) => sum + (data.runtime || 0), 0) / historicalData.length;\n    // TODO: 考虑使用早期返回或策略模式来减少嵌套\n    // TODO: 考虑使用早期返回或策略模式来减少嵌套\n    // TODO: 考虑使用早期返回或策略模式来减少嵌套\n    // TODO: 考虑使用早期返回或策略模式来减少嵌套\n    if (avgRuntime > 8000) {\n      // 年运行超过8000小时\n      probability += 0.2;\n    }\n\n    return Math.min(probability, 1.0);\n  }\n\n  /**\n   * 预测故障类型\n   */\n  predictFailureTypes(historicalData, currentHealth) {\n    const potentialFailures = [];\n\n    // 基于健康指标预测故障类型\n    // TODO: 考虑使用早期返回或策略模式来减少嵌套\n    // TODO: 考虑使用早期返回或策略模式来减少嵌套\n    // TODO: 考虑使用早期返回或策略模式来减少嵌套\n    // TODO: 考虑使用早期返回或策略模式来减少嵌套\n    if (currentHealth.health_metrics.performance < 0.6) {\n      potentialFailures.push({\n        type: 'performance_degradation',\n        probability: 0.7,\n        impact: 'medium',\n        description: '性能下降可能导致效率降低'\n      });\n    }\n\n    // TODO: 考虑使用早期返回或策略模式来减少嵌套\n    // TODO: 考虑使用早期返回或策略模式来减少嵌套\n    // TODO: 考虑使用早期返回或策略模式来减少嵌套\n    // TODO: 考虑使用早期返回或策略模式来减少嵌套\n    if (currentHealth.health_metrics.safety < 0.7) {\n      potentialFailures.push({\n        type: 'safety_issue',\n        probability: 0.6,\n        impact: 'high',\n        description: '安全指标异常可能导致设备故障'\n      });\n    }\n\n    // 基于历史数据模式识别\n    const temperatureIssues = historicalData.filter((data) => data.temperature > 80).length;\n    // TODO: 考虑使用早期返回或策略模式来减少嵌套\n    // TODO: 考虑使用早期返回或策略模式来减少嵌套\n    // TODO: 考虑使用早期返回或策略模式来减少嵌套\n    // TODO: 考虑使用早期返回或策略模式来减少嵌套\n    if (temperatureIssues > historicalData.length * 0.3) {\n      potentialFailures.push({\n        type: 'overheating',\n        probability: 0.8,\n        impact: 'high',\n        description: '过热可能导致设备损坏'\n      });\n    }\n\n    return potentialFailures;\n  }\n\n  // ==================== 数据获取方法 ====================\n\n  /**\n   * 获取设备信息\n   */\n  async getDeviceInfo(deviceId) {\n    const sql = 'SELECT * FROM devices WHERE id = ?';\n    const result = await this.queryDatabase(sql, [deviceId]);\n    return result[0] || null;\n  }\n\n  /**\n   * 获取设备性能数据\n   */\n  async getDevicePerformanceData(deviceId, timeCondition) {\n    const sql = `\n      SELECT \n        timestamp,\n        value as efficiency,\n        CASE WHEN value > 0 THEN 1 ELSE 0 END as uptime\n      FROM energy_data\n      WHERE device_id = ? AND timestamp >= datetime('now', ?)\n      ORDER BY timestamp DESC\n      LIMIT 100\n    `;\n\n    return await this.queryDatabase(sql, [deviceId, timeCondition]);\n  }\n\n  /**\n   * 获取设备传感器数据\n   */\n  async getDeviceSensorData(deviceId, timeCondition) {\n    const sql = `\n      SELECT \n        timestamp,\n        data_type,\n        value,\n        unit\n      FROM sensor_data\n      WHERE device_id = ? AND timestamp >= datetime('now', ?)\n      ORDER BY timestamp DESC\n      LIMIT 50\n    `;\n\n    const rawData = await this.queryDatabase(sql, [deviceId, timeCondition]);\n\n    // 转换为结构化数据\n    const structuredData = {};\n    rawData.forEach((item) => {\n      if (!structuredData[item.timestamp]) {\n        structuredData[item.timestamp] = { timestamp: item.timestamp };\n      }\n      structuredData[item.timestamp][item.data_type] = item.value;\n    });\n\n    return Object.values(structuredData);\n  }\n\n  /**\n   * 获取维护历史\n   */\n  async getMaintenanceHistory(deviceId, limit = 10) {\n    const sql = `\n      SELECT * FROM maintenance_records\n      WHERE device_id = ?\n      ORDER BY completed_date DESC\n      LIMIT ?\n    `;\n\n    return await this.queryDatabase(sql, [deviceId, limit]);\n  }\n\n  // ==================== 缓存和工具方法 ====================\n\n  /**\n   * 获取时间条件\n   */\n  getTimeCondition(timeRange) {\n    const conditions = {\n      '1h': '-1 hour',\n      '6h': '-6 hours',\n      '24h': '-1 day',\n      '7d': '-7 days',\n      '30d': '-30 days',\n      '90d': '-90 days',\n      '365d': '-365 days'\n    };\n    return conditions[timeRange] || '-7 days';\n  }\n\n  /**\n   * 缓存管理\n   */\n  getFromCache(key) {\n    const cached = this.cache.get(key);\n    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {\n      return cached.data;\n    }\n    return null;\n  }\n\n  setCache(key, data) {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now()\n    });\n  }\n\n  /**\n   * 数据库查询封装\n   */\n  async queryDatabase(sql, params = []) {\n    const db = await dbPromise;\n    return new Promise((resolve, reject) => {\n      db.raw(sql, params).then((rows) => {\n        resolve(rows || []);\n      }).catch((err) => {\n        reject(err);\n      });\n    });\n  }\n\n  /**\n   * 数据库执行封装\n   */\n  async runDatabase(sql, _params = []) {\n    const _db = await dbPromise;\n    return new Promise((resolve, _reject) => {\n      // 模拟数据库执行操作\n      console.log('模拟执行SQL:', sql);\n      resolve(1); // 模拟返回 lastID\n    });\n  }\n}\n\nexport default MaintenanceManager;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]