[{"filePath":"/Users/xunan/Documents/WebStormProjects/0C/src/core/services/EnergyFlowVisualization.js","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":487,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":487,"endColumn":41},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":488,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":488,"endColumn":41}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 园区能流全景图构建模块\n * 构建\"源-网-荷-储\"全环节动态能源流向图\n * 实现桑基图(Sankey Diagram)可视化展示\n */\n\nimport { EventEmitter } from 'events';\nimport logger from '../../shared/utils/logger.js';\nimport { MATH_CONSTANTS } from '../../shared/constants/MathConstants.js';\n\nclass EnergyFlowVisualization extends EventEmitter {\n  constructor() {\n    super();\n    this.isInitialized = false;\n    this.energySources = new Map(); // 源\n    this.energyGrid = new Map(); // 网\n    this.energyLoads = new Map(); // 荷\n    this.energyStorage = new Map(); // 储\n    this.flowData = new Map();\n    this.realTimeFlows = new Map();\n    this.sankeyData = null;\n    \n    // 能源流向配置\n    this.flowConfig = {\n      // 能源源头类型\n      sources: {\n        solar_pv: { name: '光伏发电', color: '#FFD700', icon: '☀️' },\n        wind: { name: '风力发电', color: '#87CEEB', icon: '💨' },\n        hydro: { name: '水力发电', color: '#4682B4', icon: '💧' },\n        grid: { name: '电网供电', color: '#808080', icon: '⚡' },\n        natural_gas: { name: '天然气', color: '#FF6347', icon: '🔥' },\n        biomass: { name: '生物质能', color: '#228B22', icon: '🌱' }\n      },\n      // 电网节点类型\n      grid_nodes: {\n        main_transformer: { name: '主变压器', color: '#4169E1', icon: '🔌' },\n        distribution_panel: { name: '配电柜', color: '#6495ED', icon: '📦' },\n        smart_meter: { name: '智能电表', color: '#00CED1', icon: '📊' }\n      },\n      // 负荷类型\n      loads: {\n        industrial: { name: '工业负荷', color: '#B22222', icon: '🏭' },\n        commercial: { name: '商业负荷', color: '#FF8C00', icon: '🏢' },\n        residential: { name: '居民负荷', color: '#32CD32', icon: '🏠' },\n        public: { name: '公共设施', color: '#9370DB', icon: '🏛️' },\n        ev_charging: { name: '充电桩', color: '#FF1493', icon: '🚗' }\n      },\n      // 储能类型\n      storage: {\n        battery: { name: '电池储能', color: '#FF4500', icon: '🔋' },\n        pumped_hydro: { name: '抽水蓄能', color: '#1E90FF', icon: '⛲' },\n        compressed_air: { name: '压缩空气', color: '#708090', icon: '💨' },\n        flywheel: { name: '飞轮储能', color: '#8A2BE2', icon: '⚙️' }\n      }\n    };\n    \n    this.init();\n  }\n\n  async init() {\n    try {\n      await this.loadEnergyInfrastructure();\n      await this.setupRealTimeMonitoring();\n      this.isInitialized = true;\n      logger.info('园区能流全景图构建模块初始化完成');\n      this.emit('initialized');\n    } catch (error) {\n      logger.error('能流全景图模块初始化失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 加载能源基础设施数据\n   */\n  async loadEnergyInfrastructure() {\n    try {\n      // 加载能源源头设备\n      const sources = await this.getEnergySourceDevices();\n      sources.forEach(source => {\n        this.energySources.set(source.id, {\n          ...source,\n          type: 'source',\n          config: this.flowConfig.sources[source.energy_type] || {}\n        });\n      });\n\n      // 加载电网设备\n      const gridDevices = await this.getGridDevices();\n      gridDevices.forEach(device => {\n        this.energyGrid.set(device.id, {\n          ...device,\n          type: 'grid',\n          config: this.flowConfig.grid_nodes[device.device_type] || {}\n        });\n      });\n\n      // 加载负荷设备\n      const loads = await this.getLoadDevices();\n      loads.forEach(load => {\n        this.energyLoads.set(load.id, {\n          ...load,\n          type: 'load',\n          config: this.flowConfig.loads[load.load_type] || {}\n        });\n      });\n\n      // 加载储能设备\n      const storageDevices = await this.getStorageDevices();\n      storageDevices.forEach(storage => {\n        this.energyStorage.set(storage.id, {\n          ...storage,\n          type: 'storage',\n          config: this.flowConfig.storage[storage.storage_type] || {}\n        });\n      });\n\n      logger.info(`已加载能源基础设施: 源${this.energySources.size}个, 网${this.energyGrid.size}个, 荷${this.energyLoads.size}个, 储${this.energyStorage.size}个`);\n    } catch (error) {\n      logger.error('加载能源基础设施失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 设置实时监控\n   */\n  async setupRealTimeMonitoring() {\n    // 每30秒更新一次能流数据\n    setInterval(async () => {\n      try {\n        await this.updateRealTimeFlows();\n        await this.generateSankeyDiagram();\n        this.emit('flow_updated', this.sankeyData);\n      } catch (error) {\n        logger.error('更新实时能流数据失败:', error);\n      }\n    }, MATH_CONSTANTS.THIRTY * MATH_CONSTANTS.MILLISECONDS_PER_SECOND);\n  }\n\n  /**\n   * 生成园区能流全景图数据\n   * @param {string} parkId - 园区ID\n   * @param {string} timeRange - 时间范围\n   * @returns {Object} 能流全景图数据\n   */\n  async generateEnergyFlowMap(parkId, timeRange = '1h') {\n    try {\n      // 获取实时能流数据\n      const flowData = await this.getRealTimeFlowData(parkId, timeRange);\n      \n      // 构建能流拓扑图\n      const topology = this.buildEnergyTopology(flowData);\n      \n      // 生成桑基图数据\n      const sankeyData = this.generateSankeyData(flowData);\n      \n      // 计算能流统计\n      const statistics = this.calculateFlowStatistics(flowData);\n      \n      const energyFlowMap = {\n        park_id: parkId,\n        time_range: timeRange,\n        timestamp: new Date().toISOString(),\n        topology,\n        sankey_data: sankeyData,\n        statistics,\n        real_time_flows: this.realTimeFlows.get(parkId) || [],\n        infrastructure: {\n          sources: Array.from(this.energySources.values()),\n          grid_nodes: Array.from(this.energyGrid.values()),\n          loads: Array.from(this.energyLoads.values()),\n          storage: Array.from(this.energyStorage.values())\n        }\n      };\n\n      return energyFlowMap;\n    } catch (error) {\n      logger.error('生成园区能流全景图失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 构建能源拓扑图\n   * @param {Array} flowData - 能流数据\n   * @returns {Object} 拓扑图数据\n   */\n  buildEnergyTopology(flowData) {\n    const nodes = [];\n    const links = [];\n    const nodeMap = new Map();\n\n    // 添加所有设备节点\n    const allDevices = [\n      ...Array.from(this.energySources.values()),\n      ...Array.from(this.energyGrid.values()),\n      ...Array.from(this.energyLoads.values()),\n      ...Array.from(this.energyStorage.values())\n    ];\n\n    allDevices.forEach(device => {\n      const node = {\n        id: device.id,\n        name: device.name,\n        type: device.type,\n        category: device.energy_type || device.device_type || device.load_type || device.storage_type,\n        config: device.config,\n        position: device.position || this.calculateNodePosition(device),\n        capacity: device.capacity || device.rated_power || 0,\n        current_power: 0,\n        efficiency: device.efficiency || 1.0,\n        status: device.status || 'online'\n      };\n      nodes.push(node);\n      nodeMap.set(device.id, node);\n    });\n\n    // 添加能流连接\n    flowData.forEach(flow => {\n      const sourceNode = nodeMap.get(flow.source_id);\n      const targetNode = nodeMap.get(flow.target_id);\n      \n      if (sourceNode && targetNode) {\n        // 更新节点功率\n        sourceNode.current_power = (sourceNode.current_power || 0) + flow.power;\n        targetNode.current_power = (targetNode.current_power || 0) + flow.power;\n        \n        // 添加连接\n        links.push({\n          source: flow.source_id,\n          target: flow.target_id,\n          power: flow.power,\n          energy: flow.energy,\n          efficiency: flow.efficiency || 1.0,\n          flow_direction: flow.direction || 'forward',\n          line_loss: flow.line_loss || 0,\n          timestamp: flow.timestamp\n        });\n      }\n    });\n\n    return {\n      nodes,\n      links,\n      layout: 'force_directed', // 或 'hierarchical', 'circular'\n      zoom_level: 1.0,\n      center_point: { x: 0, y: 0 }\n    };\n  }\n\n  /**\n   * 生成桑基图数据\n   * @param {Array} flowData - 能流数据\n   * @returns {Object} 桑基图数据\n   */\n  generateSankeyData(flowData) {\n    const nodes = [];\n    const links = [];\n    const nodeIndex = new Map();\n    let nodeCounter = 0;\n\n    // 按层级组织节点\n    const layers = {\n      sources: [], // 第一层：能源源头\n      grid: [],    // 第二层：电网节点\n      storage: [], // 第三层：储能设备\n      loads: []    // 第四层：负荷\n    };\n\n    // 分类设备到不同层级\n    this.energySources.forEach(source => {\n      const nodeId = nodeCounter++;\n      const node = {\n        id: nodeId,\n        name: source.name,\n        category: 'source',\n        layer: 0,\n        color: source.config.color || '#FFD700',\n        icon: source.config.icon || '⚡'\n      };\n      nodes.push(node);\n      nodeIndex.set(source.id, nodeId);\n      layers.sources.push(node);\n    });\n\n    this.energyGrid.forEach(grid => {\n      const nodeId = nodeCounter++;\n      const node = {\n        id: nodeId,\n        name: grid.name,\n        category: 'grid',\n        layer: 1,\n        color: grid.config.color || '#4169E1',\n        icon: grid.config.icon || '🔌'\n      };\n      nodes.push(node);\n      nodeIndex.set(grid.id, nodeId);\n      layers.grid.push(node);\n    });\n\n    this.energyStorage.forEach(storage => {\n      const nodeId = nodeCounter++;\n      const node = {\n        id: nodeId,\n        name: storage.name,\n        category: 'storage',\n        layer: 2,\n        color: storage.config.color || '#FF4500',\n        icon: storage.config.icon || '🔋'\n      };\n      nodes.push(node);\n      nodeIndex.set(storage.id, nodeId);\n      layers.storage.push(node);\n    });\n\n    this.energyLoads.forEach(load => {\n      const nodeId = nodeCounter++;\n      const node = {\n        id: nodeId,\n        name: load.name,\n        category: 'load',\n        layer: 3,\n        color: load.config.color || '#B22222',\n        icon: load.config.icon || '🏭'\n      };\n      nodes.push(node);\n      nodeIndex.set(load.id, nodeId);\n      layers.loads.push(node);\n    });\n\n    // 生成连接数据\n    flowData.forEach(flow => {\n      const sourceIndex = nodeIndex.get(flow.source_id);\n      const targetIndex = nodeIndex.get(flow.target_id);\n      \n      if (sourceIndex !== undefined && targetIndex !== undefined) {\n        links.push({\n          source: sourceIndex,\n          target: targetIndex,\n          value: flow.power, // 功率作为流量值\n          energy: flow.energy,\n          efficiency: flow.efficiency || 1.0,\n          color: this.getFlowColor(flow.power),\n          opacity: this.getFlowOpacity(flow.power)\n        });\n      }\n    });\n\n    return {\n      nodes,\n      links,\n      layers,\n      layout: {\n        node_width: 20,\n        node_padding: 10,\n        iterations: 32,\n        link_curvature: 0.5\n      },\n      animation: {\n        enabled: true,\n        duration: 1000,\n        easing: 'ease-in-out'\n      }\n    };\n  }\n\n  /**\n   * 计算能流统计\n   * @param {Array} flowData - 能流数据\n   * @returns {Object} 统计数据\n   */\n  calculateFlowStatistics(flowData) {\n    const stats = {\n      total_generation: 0,\n      total_consumption: 0,\n      total_storage_charge: 0,\n      total_storage_discharge: 0,\n      grid_import: 0,\n      grid_export: 0,\n      renewable_ratio: 0,\n      energy_efficiency: 0,\n      peak_power: 0,\n      average_power: 0,\n      power_balance: 0,\n      breakdown: {\n        by_source: {},\n        by_load: {},\n        by_storage: {},\n        by_time: []\n      }\n    };\n\n    // 按源头统计\n    this.energySources.forEach(source => {\n      const sourceFlows = flowData.filter(f => f.source_id === source.id);\n      const totalPower = sourceFlows.reduce((sum, f) => sum + f.power, 0);\n      stats.breakdown.by_source[source.energy_type] = totalPower;\n      stats.total_generation += totalPower;\n    });\n\n    // 按负荷统计\n    this.energyLoads.forEach(load => {\n      const loadFlows = flowData.filter(f => f.target_id === load.id);\n      const totalPower = loadFlows.reduce((sum, f) => sum + f.power, 0);\n      stats.breakdown.by_load[load.load_type] = totalPower;\n      stats.total_consumption += totalPower;\n    });\n\n    // 按储能统计\n    this.energyStorage.forEach(storage => {\n      const chargeFlows = flowData.filter(f => f.target_id === storage.id);\n      const dischargeFlows = flowData.filter(f => f.source_id === storage.id);\n      \n      const chargeTotal = chargeFlows.reduce((sum, f) => sum + f.power, 0);\n      const dischargeTotal = dischargeFlows.reduce((sum, f) => sum + f.power, 0);\n      \n      stats.breakdown.by_storage[storage.storage_type] = {\n        charge: chargeTotal,\n        discharge: dischargeTotal,\n        net: dischargeTotal - chargeTotal\n      };\n      \n      stats.total_storage_charge += chargeTotal;\n      stats.total_storage_discharge += dischargeTotal;\n    });\n\n    // 计算可再生能源占比\n    const renewableSources = ['solar_pv', 'wind', 'hydro', 'biomass'];\n    const renewableGeneration = renewableSources.reduce((sum, type) => {\n      return sum + (stats.breakdown.by_source[type] || 0);\n    }, 0);\n    stats.renewable_ratio = stats.total_generation > 0 ? \n      (renewableGeneration / stats.total_generation * MATH_CONSTANTS.ONE_HUNDRED).toFixed(MATH_CONSTANTS.DECIMAL_PLACES) : 0;\n\n    // 计算功率平衡\n    stats.power_balance = stats.total_generation - stats.total_consumption;\n    \n    // 计算平均功率\n    stats.average_power = flowData.length > 0 ? \n      flowData.reduce((sum, f) => sum + f.power, 0) / flowData.length : 0;\n    \n    // 计算峰值功率\n    stats.peak_power = flowData.length > 0 ? \n      Math.max(...flowData.map(f => f.power)) : 0;\n\n    return stats;\n  }\n\n  /**\n   * 更新实时能流数据\n   */\n  async updateRealTimeFlows() {\n    try {\n      const parks = await this.getAllParks();\n      \n      for (const park of parks) {\n        const flowData = await this.getRealTimeFlowData(park.id, '5m');\n        this.realTimeFlows.set(park.id, flowData);\n        \n        // 发送实时更新事件\n        this.emit('real_time_flow_update', {\n          park_id: park.id,\n          flows: flowData,\n          timestamp: new Date().toISOString()\n        });\n      }\n    } catch (error) {\n      logger.error('更新实时能流数据失败:', error);\n    }\n  }\n\n  /**\n   * 计算节点位置\n   */\n  calculateNodePosition(device) {\n    // 根据设备类型计算布局位置\n    const typePositions = {\n      source: { x: 0, y: 0 },\n      grid: { x: 200, y: 0 },\n      storage: { x: 400, y: 0 },\n      load: { x: 600, y: 0 }\n    };\n    \n    const basePos = typePositions[device.type] || { x: 0, y: 0 };\n    return {\n      x: basePos.x + Math.random() * 100,\n      y: basePos.y + Math.random() * 100\n    };\n  }\n\n  /**\n   * 获取能流颜色\n   */\n  getFlowColor(power) {\n    if (power > MATH_CONSTANTS.ONE_THOUSAND) {\n      return '#FF0000'; // 高功率：红色\n    }\n    if (power > MATH_CONSTANTS.FIVE_HUNDRED) {\n      return '#FF8C00';  // 中功率：橙色\n    }\n    if (power > MATH_CONSTANTS.ONE_HUNDRED) {\n      return '#FFD700';  // 低功率：金色\n    }\n    return '#90EE90'; // 极低功率：浅绿色\n  }\n\n  /**\n   * 获取能流透明度\n   */\n  getFlowOpacity(power) {\n    const maxPower = MATH_CONSTANTS.TWO_THOUSAND;\n    const minOpacity = MATH_CONSTANTS.POINT_THREE;\n    const maxOpacity = MATH_CONSTANTS.ONE_POINT_ZERO;\n    \n    const ratio = Math.min(power / maxPower, 1);\n    return minOpacity + (maxOpacity - minOpacity) * ratio;\n  }\n\n  // 模拟数据获取方法（实际应用中需要连接真实数据源）\n  async getEnergySourceDevices() {\n    return [\n      { id: 'solar_001', name: '光伏电站1', energy_type: 'solar_pv', capacity: 1000, efficiency: 0.85 },\n      { id: 'wind_001', name: '风力发电机1', energy_type: 'wind', capacity: 500, efficiency: 0.90 },\n      { id: 'grid_001', name: '电网接入点', energy_type: 'grid', capacity: 5000, efficiency: 0.95 }\n    ];\n  }\n\n  async getGridDevices() {\n    return [\n      { id: 'transformer_001', name: '主变压器', device_type: 'main_transformer', capacity: 5000 },\n      { id: 'panel_001', name: '配电柜1', device_type: 'distribution_panel', capacity: 1000 }\n    ];\n  }\n\n  async getLoadDevices() {\n    return [\n      { id: 'factory_001', name: '工厂1', load_type: 'industrial', capacity: 2000 },\n      { id: 'office_001', name: '办公楼1', load_type: 'commercial', capacity: 500 },\n      { id: 'charging_001', name: '充电站1', load_type: 'ev_charging', capacity: 300 }\n    ];\n  }\n\n  async getStorageDevices() {\n    return [\n      { id: 'battery_001', name: '电池储能1', storage_type: 'battery', capacity: 1000, efficiency: 0.90 }\n    ];\n  }\n\n  async getRealTimeFlowData(_parkId, _timeRange) {\n    // TODO: 实现真实的数据库查询\n    return [\n      {\n        source_id: 'solar_001',\n        target_id: 'transformer_001',\n        power: Math.random() * MATH_CONSTANTS.EIGHT_HUNDRED + MATH_CONSTANTS.TWO_HUNDRED,\n        energy: Math.random() * MATH_CONSTANTS.ONE_THOUSAND,\n        efficiency: 0.95,\n        direction: 'forward',\n        timestamp: new Date().toISOString()\n      },\n      {\n        source_id: 'transformer_001',\n        target_id: 'factory_001',\n        power: Math.random() * MATH_CONSTANTS.FIFTEEN_HUNDRED + MATH_CONSTANTS.FIVE_HUNDRED,\n        energy: Math.random() * MATH_CONSTANTS.TWO_THOUSAND + MATH_CONSTANTS.ONE_THOUSAND,\n        efficiency: 0.98,\n        direction: 'forward',\n        timestamp: new Date().toISOString()\n      }\n    ];\n  }\n\n  async getAllParks() {\n    return [\n      { id: 'park_001', name: '示例园区1' }\n    ];\n  }\n}\n\nexport default EnergyFlowVisualization;","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]