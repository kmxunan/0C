[{"filePath":"/Users/xunan/Documents/WebStormProjects/0C/src/core/services/EnergyFlowVisualization.js","messages":[{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":487,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":487,"endColumn":41},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 100.","line":488,"column":38,"nodeType":"Literal","messageId":"noMagic","endLine":488,"endColumn":41}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * å›­åŒºèƒ½æµå…¨æ™¯å›¾æ„å»ºæ¨¡å—\n * æ„å»º\"æº-ç½‘-è·-å‚¨\"å…¨ç¯èŠ‚åŠ¨æ€èƒ½æºæµå‘å›¾\n * å®ç°æ¡‘åŸºå›¾(Sankey Diagram)å¯è§†åŒ–å±•ç¤º\n */\n\nimport { EventEmitter } from 'events';\nimport logger from '../../shared/utils/logger.js';\nimport { MATH_CONSTANTS } from '../../shared/constants/MathConstants.js';\n\nclass EnergyFlowVisualization extends EventEmitter {\n  constructor() {\n    super();\n    this.isInitialized = false;\n    this.energySources = new Map(); // æº\n    this.energyGrid = new Map(); // ç½‘\n    this.energyLoads = new Map(); // è·\n    this.energyStorage = new Map(); // å‚¨\n    this.flowData = new Map();\n    this.realTimeFlows = new Map();\n    this.sankeyData = null;\n    \n    // èƒ½æºæµå‘é…ç½®\n    this.flowConfig = {\n      // èƒ½æºæºå¤´ç±»å‹\n      sources: {\n        solar_pv: { name: 'å…‰ä¼å‘ç”µ', color: '#FFD700', icon: 'â˜€ï¸' },\n        wind: { name: 'é£åŠ›å‘ç”µ', color: '#87CEEB', icon: 'ğŸ’¨' },\n        hydro: { name: 'æ°´åŠ›å‘ç”µ', color: '#4682B4', icon: 'ğŸ’§' },\n        grid: { name: 'ç”µç½‘ä¾›ç”µ', color: '#808080', icon: 'âš¡' },\n        natural_gas: { name: 'å¤©ç„¶æ°”', color: '#FF6347', icon: 'ğŸ”¥' },\n        biomass: { name: 'ç”Ÿç‰©è´¨èƒ½', color: '#228B22', icon: 'ğŸŒ±' }\n      },\n      // ç”µç½‘èŠ‚ç‚¹ç±»å‹\n      grid_nodes: {\n        main_transformer: { name: 'ä¸»å˜å‹å™¨', color: '#4169E1', icon: 'ğŸ”Œ' },\n        distribution_panel: { name: 'é…ç”µæŸœ', color: '#6495ED', icon: 'ğŸ“¦' },\n        smart_meter: { name: 'æ™ºèƒ½ç”µè¡¨', color: '#00CED1', icon: 'ğŸ“Š' }\n      },\n      // è´Ÿè·ç±»å‹\n      loads: {\n        industrial: { name: 'å·¥ä¸šè´Ÿè·', color: '#B22222', icon: 'ğŸ­' },\n        commercial: { name: 'å•†ä¸šè´Ÿè·', color: '#FF8C00', icon: 'ğŸ¢' },\n        residential: { name: 'å±…æ°‘è´Ÿè·', color: '#32CD32', icon: 'ğŸ ' },\n        public: { name: 'å…¬å…±è®¾æ–½', color: '#9370DB', icon: 'ğŸ›ï¸' },\n        ev_charging: { name: 'å……ç”µæ¡©', color: '#FF1493', icon: 'ğŸš—' }\n      },\n      // å‚¨èƒ½ç±»å‹\n      storage: {\n        battery: { name: 'ç”µæ± å‚¨èƒ½', color: '#FF4500', icon: 'ğŸ”‹' },\n        pumped_hydro: { name: 'æŠ½æ°´è“„èƒ½', color: '#1E90FF', icon: 'â›²' },\n        compressed_air: { name: 'å‹ç¼©ç©ºæ°”', color: '#708090', icon: 'ğŸ’¨' },\n        flywheel: { name: 'é£è½®å‚¨èƒ½', color: '#8A2BE2', icon: 'âš™ï¸' }\n      }\n    };\n    \n    this.init();\n  }\n\n  async init() {\n    try {\n      await this.loadEnergyInfrastructure();\n      await this.setupRealTimeMonitoring();\n      this.isInitialized = true;\n      logger.info('å›­åŒºèƒ½æµå…¨æ™¯å›¾æ„å»ºæ¨¡å—åˆå§‹åŒ–å®Œæˆ');\n      this.emit('initialized');\n    } catch (error) {\n      logger.error('èƒ½æµå…¨æ™¯å›¾æ¨¡å—åˆå§‹åŒ–å¤±è´¥:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * åŠ è½½èƒ½æºåŸºç¡€è®¾æ–½æ•°æ®\n   */\n  async loadEnergyInfrastructure() {\n    try {\n      // åŠ è½½èƒ½æºæºå¤´è®¾å¤‡\n      const sources = await this.getEnergySourceDevices();\n      sources.forEach(source => {\n        this.energySources.set(source.id, {\n          ...source,\n          type: 'source',\n          config: this.flowConfig.sources[source.energy_type] || {}\n        });\n      });\n\n      // åŠ è½½ç”µç½‘è®¾å¤‡\n      const gridDevices = await this.getGridDevices();\n      gridDevices.forEach(device => {\n        this.energyGrid.set(device.id, {\n          ...device,\n          type: 'grid',\n          config: this.flowConfig.grid_nodes[device.device_type] || {}\n        });\n      });\n\n      // åŠ è½½è´Ÿè·è®¾å¤‡\n      const loads = await this.getLoadDevices();\n      loads.forEach(load => {\n        this.energyLoads.set(load.id, {\n          ...load,\n          type: 'load',\n          config: this.flowConfig.loads[load.load_type] || {}\n        });\n      });\n\n      // åŠ è½½å‚¨èƒ½è®¾å¤‡\n      const storageDevices = await this.getStorageDevices();\n      storageDevices.forEach(storage => {\n        this.energyStorage.set(storage.id, {\n          ...storage,\n          type: 'storage',\n          config: this.flowConfig.storage[storage.storage_type] || {}\n        });\n      });\n\n      logger.info(`å·²åŠ è½½èƒ½æºåŸºç¡€è®¾æ–½: æº${this.energySources.size}ä¸ª, ç½‘${this.energyGrid.size}ä¸ª, è·${this.energyLoads.size}ä¸ª, å‚¨${this.energyStorage.size}ä¸ª`);\n    } catch (error) {\n      logger.error('åŠ è½½èƒ½æºåŸºç¡€è®¾æ–½å¤±è´¥:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * è®¾ç½®å®æ—¶ç›‘æ§\n   */\n  async setupRealTimeMonitoring() {\n    // æ¯30ç§’æ›´æ–°ä¸€æ¬¡èƒ½æµæ•°æ®\n    setInterval(async () => {\n      try {\n        await this.updateRealTimeFlows();\n        await this.generateSankeyDiagram();\n        this.emit('flow_updated', this.sankeyData);\n      } catch (error) {\n        logger.error('æ›´æ–°å®æ—¶èƒ½æµæ•°æ®å¤±è´¥:', error);\n      }\n    }, MATH_CONSTANTS.THIRTY * MATH_CONSTANTS.MILLISECONDS_PER_SECOND);\n  }\n\n  /**\n   * ç”Ÿæˆå›­åŒºèƒ½æµå…¨æ™¯å›¾æ•°æ®\n   * @param {string} parkId - å›­åŒºID\n   * @param {string} timeRange - æ—¶é—´èŒƒå›´\n   * @returns {Object} èƒ½æµå…¨æ™¯å›¾æ•°æ®\n   */\n  async generateEnergyFlowMap(parkId, timeRange = '1h') {\n    try {\n      // è·å–å®æ—¶èƒ½æµæ•°æ®\n      const flowData = await this.getRealTimeFlowData(parkId, timeRange);\n      \n      // æ„å»ºèƒ½æµæ‹“æ‰‘å›¾\n      const topology = this.buildEnergyTopology(flowData);\n      \n      // ç”Ÿæˆæ¡‘åŸºå›¾æ•°æ®\n      const sankeyData = this.generateSankeyData(flowData);\n      \n      // è®¡ç®—èƒ½æµç»Ÿè®¡\n      const statistics = this.calculateFlowStatistics(flowData);\n      \n      const energyFlowMap = {\n        park_id: parkId,\n        time_range: timeRange,\n        timestamp: new Date().toISOString(),\n        topology,\n        sankey_data: sankeyData,\n        statistics,\n        real_time_flows: this.realTimeFlows.get(parkId) || [],\n        infrastructure: {\n          sources: Array.from(this.energySources.values()),\n          grid_nodes: Array.from(this.energyGrid.values()),\n          loads: Array.from(this.energyLoads.values()),\n          storage: Array.from(this.energyStorage.values())\n        }\n      };\n\n      return energyFlowMap;\n    } catch (error) {\n      logger.error('ç”Ÿæˆå›­åŒºèƒ½æµå…¨æ™¯å›¾å¤±è´¥:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * æ„å»ºèƒ½æºæ‹“æ‰‘å›¾\n   * @param {Array} flowData - èƒ½æµæ•°æ®\n   * @returns {Object} æ‹“æ‰‘å›¾æ•°æ®\n   */\n  buildEnergyTopology(flowData) {\n    const nodes = [];\n    const links = [];\n    const nodeMap = new Map();\n\n    // æ·»åŠ æ‰€æœ‰è®¾å¤‡èŠ‚ç‚¹\n    const allDevices = [\n      ...Array.from(this.energySources.values()),\n      ...Array.from(this.energyGrid.values()),\n      ...Array.from(this.energyLoads.values()),\n      ...Array.from(this.energyStorage.values())\n    ];\n\n    allDevices.forEach(device => {\n      const node = {\n        id: device.id,\n        name: device.name,\n        type: device.type,\n        category: device.energy_type || device.device_type || device.load_type || device.storage_type,\n        config: device.config,\n        position: device.position || this.calculateNodePosition(device),\n        capacity: device.capacity || device.rated_power || 0,\n        current_power: 0,\n        efficiency: device.efficiency || 1.0,\n        status: device.status || 'online'\n      };\n      nodes.push(node);\n      nodeMap.set(device.id, node);\n    });\n\n    // æ·»åŠ èƒ½æµè¿æ¥\n    flowData.forEach(flow => {\n      const sourceNode = nodeMap.get(flow.source_id);\n      const targetNode = nodeMap.get(flow.target_id);\n      \n      if (sourceNode && targetNode) {\n        // æ›´æ–°èŠ‚ç‚¹åŠŸç‡\n        sourceNode.current_power = (sourceNode.current_power || 0) + flow.power;\n        targetNode.current_power = (targetNode.current_power || 0) + flow.power;\n        \n        // æ·»åŠ è¿æ¥\n        links.push({\n          source: flow.source_id,\n          target: flow.target_id,\n          power: flow.power,\n          energy: flow.energy,\n          efficiency: flow.efficiency || 1.0,\n          flow_direction: flow.direction || 'forward',\n          line_loss: flow.line_loss || 0,\n          timestamp: flow.timestamp\n        });\n      }\n    });\n\n    return {\n      nodes,\n      links,\n      layout: 'force_directed', // æˆ– 'hierarchical', 'circular'\n      zoom_level: 1.0,\n      center_point: { x: 0, y: 0 }\n    };\n  }\n\n  /**\n   * ç”Ÿæˆæ¡‘åŸºå›¾æ•°æ®\n   * @param {Array} flowData - èƒ½æµæ•°æ®\n   * @returns {Object} æ¡‘åŸºå›¾æ•°æ®\n   */\n  generateSankeyData(flowData) {\n    const nodes = [];\n    const links = [];\n    const nodeIndex = new Map();\n    let nodeCounter = 0;\n\n    // æŒ‰å±‚çº§ç»„ç»‡èŠ‚ç‚¹\n    const layers = {\n      sources: [], // ç¬¬ä¸€å±‚ï¼šèƒ½æºæºå¤´\n      grid: [],    // ç¬¬äºŒå±‚ï¼šç”µç½‘èŠ‚ç‚¹\n      storage: [], // ç¬¬ä¸‰å±‚ï¼šå‚¨èƒ½è®¾å¤‡\n      loads: []    // ç¬¬å››å±‚ï¼šè´Ÿè·\n    };\n\n    // åˆ†ç±»è®¾å¤‡åˆ°ä¸åŒå±‚çº§\n    this.energySources.forEach(source => {\n      const nodeId = nodeCounter++;\n      const node = {\n        id: nodeId,\n        name: source.name,\n        category: 'source',\n        layer: 0,\n        color: source.config.color || '#FFD700',\n        icon: source.config.icon || 'âš¡'\n      };\n      nodes.push(node);\n      nodeIndex.set(source.id, nodeId);\n      layers.sources.push(node);\n    });\n\n    this.energyGrid.forEach(grid => {\n      const nodeId = nodeCounter++;\n      const node = {\n        id: nodeId,\n        name: grid.name,\n        category: 'grid',\n        layer: 1,\n        color: grid.config.color || '#4169E1',\n        icon: grid.config.icon || 'ğŸ”Œ'\n      };\n      nodes.push(node);\n      nodeIndex.set(grid.id, nodeId);\n      layers.grid.push(node);\n    });\n\n    this.energyStorage.forEach(storage => {\n      const nodeId = nodeCounter++;\n      const node = {\n        id: nodeId,\n        name: storage.name,\n        category: 'storage',\n        layer: 2,\n        color: storage.config.color || '#FF4500',\n        icon: storage.config.icon || 'ğŸ”‹'\n      };\n      nodes.push(node);\n      nodeIndex.set(storage.id, nodeId);\n      layers.storage.push(node);\n    });\n\n    this.energyLoads.forEach(load => {\n      const nodeId = nodeCounter++;\n      const node = {\n        id: nodeId,\n        name: load.name,\n        category: 'load',\n        layer: 3,\n        color: load.config.color || '#B22222',\n        icon: load.config.icon || 'ğŸ­'\n      };\n      nodes.push(node);\n      nodeIndex.set(load.id, nodeId);\n      layers.loads.push(node);\n    });\n\n    // ç”Ÿæˆè¿æ¥æ•°æ®\n    flowData.forEach(flow => {\n      const sourceIndex = nodeIndex.get(flow.source_id);\n      const targetIndex = nodeIndex.get(flow.target_id);\n      \n      if (sourceIndex !== undefined && targetIndex !== undefined) {\n        links.push({\n          source: sourceIndex,\n          target: targetIndex,\n          value: flow.power, // åŠŸç‡ä½œä¸ºæµé‡å€¼\n          energy: flow.energy,\n          efficiency: flow.efficiency || 1.0,\n          color: this.getFlowColor(flow.power),\n          opacity: this.getFlowOpacity(flow.power)\n        });\n      }\n    });\n\n    return {\n      nodes,\n      links,\n      layers,\n      layout: {\n        node_width: 20,\n        node_padding: 10,\n        iterations: 32,\n        link_curvature: 0.5\n      },\n      animation: {\n        enabled: true,\n        duration: 1000,\n        easing: 'ease-in-out'\n      }\n    };\n  }\n\n  /**\n   * è®¡ç®—èƒ½æµç»Ÿè®¡\n   * @param {Array} flowData - èƒ½æµæ•°æ®\n   * @returns {Object} ç»Ÿè®¡æ•°æ®\n   */\n  calculateFlowStatistics(flowData) {\n    const stats = {\n      total_generation: 0,\n      total_consumption: 0,\n      total_storage_charge: 0,\n      total_storage_discharge: 0,\n      grid_import: 0,\n      grid_export: 0,\n      renewable_ratio: 0,\n      energy_efficiency: 0,\n      peak_power: 0,\n      average_power: 0,\n      power_balance: 0,\n      breakdown: {\n        by_source: {},\n        by_load: {},\n        by_storage: {},\n        by_time: []\n      }\n    };\n\n    // æŒ‰æºå¤´ç»Ÿè®¡\n    this.energySources.forEach(source => {\n      const sourceFlows = flowData.filter(f => f.source_id === source.id);\n      const totalPower = sourceFlows.reduce((sum, f) => sum + f.power, 0);\n      stats.breakdown.by_source[source.energy_type] = totalPower;\n      stats.total_generation += totalPower;\n    });\n\n    // æŒ‰è´Ÿè·ç»Ÿè®¡\n    this.energyLoads.forEach(load => {\n      const loadFlows = flowData.filter(f => f.target_id === load.id);\n      const totalPower = loadFlows.reduce((sum, f) => sum + f.power, 0);\n      stats.breakdown.by_load[load.load_type] = totalPower;\n      stats.total_consumption += totalPower;\n    });\n\n    // æŒ‰å‚¨èƒ½ç»Ÿè®¡\n    this.energyStorage.forEach(storage => {\n      const chargeFlows = flowData.filter(f => f.target_id === storage.id);\n      const dischargeFlows = flowData.filter(f => f.source_id === storage.id);\n      \n      const chargeTotal = chargeFlows.reduce((sum, f) => sum + f.power, 0);\n      const dischargeTotal = dischargeFlows.reduce((sum, f) => sum + f.power, 0);\n      \n      stats.breakdown.by_storage[storage.storage_type] = {\n        charge: chargeTotal,\n        discharge: dischargeTotal,\n        net: dischargeTotal - chargeTotal\n      };\n      \n      stats.total_storage_charge += chargeTotal;\n      stats.total_storage_discharge += dischargeTotal;\n    });\n\n    // è®¡ç®—å¯å†ç”Ÿèƒ½æºå æ¯”\n    const renewableSources = ['solar_pv', 'wind', 'hydro', 'biomass'];\n    const renewableGeneration = renewableSources.reduce((sum, type) => {\n      return sum + (stats.breakdown.by_source[type] || 0);\n    }, 0);\n    stats.renewable_ratio = stats.total_generation > 0 ? \n      (renewableGeneration / stats.total_generation * MATH_CONSTANTS.ONE_HUNDRED).toFixed(MATH_CONSTANTS.DECIMAL_PLACES) : 0;\n\n    // è®¡ç®—åŠŸç‡å¹³è¡¡\n    stats.power_balance = stats.total_generation - stats.total_consumption;\n    \n    // è®¡ç®—å¹³å‡åŠŸç‡\n    stats.average_power = flowData.length > 0 ? \n      flowData.reduce((sum, f) => sum + f.power, 0) / flowData.length : 0;\n    \n    // è®¡ç®—å³°å€¼åŠŸç‡\n    stats.peak_power = flowData.length > 0 ? \n      Math.max(...flowData.map(f => f.power)) : 0;\n\n    return stats;\n  }\n\n  /**\n   * æ›´æ–°å®æ—¶èƒ½æµæ•°æ®\n   */\n  async updateRealTimeFlows() {\n    try {\n      const parks = await this.getAllParks();\n      \n      for (const park of parks) {\n        const flowData = await this.getRealTimeFlowData(park.id, '5m');\n        this.realTimeFlows.set(park.id, flowData);\n        \n        // å‘é€å®æ—¶æ›´æ–°äº‹ä»¶\n        this.emit('real_time_flow_update', {\n          park_id: park.id,\n          flows: flowData,\n          timestamp: new Date().toISOString()\n        });\n      }\n    } catch (error) {\n      logger.error('æ›´æ–°å®æ—¶èƒ½æµæ•°æ®å¤±è´¥:', error);\n    }\n  }\n\n  /**\n   * è®¡ç®—èŠ‚ç‚¹ä½ç½®\n   */\n  calculateNodePosition(device) {\n    // æ ¹æ®è®¾å¤‡ç±»å‹è®¡ç®—å¸ƒå±€ä½ç½®\n    const typePositions = {\n      source: { x: 0, y: 0 },\n      grid: { x: 200, y: 0 },\n      storage: { x: 400, y: 0 },\n      load: { x: 600, y: 0 }\n    };\n    \n    const basePos = typePositions[device.type] || { x: 0, y: 0 };\n    return {\n      x: basePos.x + Math.random() * 100,\n      y: basePos.y + Math.random() * 100\n    };\n  }\n\n  /**\n   * è·å–èƒ½æµé¢œè‰²\n   */\n  getFlowColor(power) {\n    if (power > MATH_CONSTANTS.ONE_THOUSAND) {\n      return '#FF0000'; // é«˜åŠŸç‡ï¼šçº¢è‰²\n    }\n    if (power > MATH_CONSTANTS.FIVE_HUNDRED) {\n      return '#FF8C00';  // ä¸­åŠŸç‡ï¼šæ©™è‰²\n    }\n    if (power > MATH_CONSTANTS.ONE_HUNDRED) {\n      return '#FFD700';  // ä½åŠŸç‡ï¼šé‡‘è‰²\n    }\n    return '#90EE90'; // æä½åŠŸç‡ï¼šæµ…ç»¿è‰²\n  }\n\n  /**\n   * è·å–èƒ½æµé€æ˜åº¦\n   */\n  getFlowOpacity(power) {\n    const maxPower = MATH_CONSTANTS.TWO_THOUSAND;\n    const minOpacity = MATH_CONSTANTS.POINT_THREE;\n    const maxOpacity = MATH_CONSTANTS.ONE_POINT_ZERO;\n    \n    const ratio = Math.min(power / maxPower, 1);\n    return minOpacity + (maxOpacity - minOpacity) * ratio;\n  }\n\n  // æ¨¡æ‹Ÿæ•°æ®è·å–æ–¹æ³•ï¼ˆå®é™…åº”ç”¨ä¸­éœ€è¦è¿æ¥çœŸå®æ•°æ®æºï¼‰\n  async getEnergySourceDevices() {\n    return [\n      { id: 'solar_001', name: 'å…‰ä¼ç”µç«™1', energy_type: 'solar_pv', capacity: 1000, efficiency: 0.85 },\n      { id: 'wind_001', name: 'é£åŠ›å‘ç”µæœº1', energy_type: 'wind', capacity: 500, efficiency: 0.90 },\n      { id: 'grid_001', name: 'ç”µç½‘æ¥å…¥ç‚¹', energy_type: 'grid', capacity: 5000, efficiency: 0.95 }\n    ];\n  }\n\n  async getGridDevices() {\n    return [\n      { id: 'transformer_001', name: 'ä¸»å˜å‹å™¨', device_type: 'main_transformer', capacity: 5000 },\n      { id: 'panel_001', name: 'é…ç”µæŸœ1', device_type: 'distribution_panel', capacity: 1000 }\n    ];\n  }\n\n  async getLoadDevices() {\n    return [\n      { id: 'factory_001', name: 'å·¥å‚1', load_type: 'industrial', capacity: 2000 },\n      { id: 'office_001', name: 'åŠå…¬æ¥¼1', load_type: 'commercial', capacity: 500 },\n      { id: 'charging_001', name: 'å……ç”µç«™1', load_type: 'ev_charging', capacity: 300 }\n    ];\n  }\n\n  async getStorageDevices() {\n    return [\n      { id: 'battery_001', name: 'ç”µæ± å‚¨èƒ½1', storage_type: 'battery', capacity: 1000, efficiency: 0.90 }\n    ];\n  }\n\n  async getRealTimeFlowData(_parkId, _timeRange) {\n    // TODO: å®ç°çœŸå®çš„æ•°æ®åº“æŸ¥è¯¢\n    return [\n      {\n        source_id: 'solar_001',\n        target_id: 'transformer_001',\n        power: Math.random() * MATH_CONSTANTS.EIGHT_HUNDRED + MATH_CONSTANTS.TWO_HUNDRED,\n        energy: Math.random() * MATH_CONSTANTS.ONE_THOUSAND,\n        efficiency: 0.95,\n        direction: 'forward',\n        timestamp: new Date().toISOString()\n      },\n      {\n        source_id: 'transformer_001',\n        target_id: 'factory_001',\n        power: Math.random() * MATH_CONSTANTS.FIFTEEN_HUNDRED + MATH_CONSTANTS.FIVE_HUNDRED,\n        energy: Math.random() * MATH_CONSTANTS.TWO_THOUSAND + MATH_CONSTANTS.ONE_THOUSAND,\n        efficiency: 0.98,\n        direction: 'forward',\n        timestamp: new Date().toISOString()\n      }\n    ];\n  }\n\n  async getAllParks() {\n    return [\n      { id: 'park_001', name: 'ç¤ºä¾‹å›­åŒº1' }\n    ];\n  }\n}\n\nexport default EnergyFlowVisualization;","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]